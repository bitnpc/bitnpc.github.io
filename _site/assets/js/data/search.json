[
  
  {
    "title": "色域显示",
    "url": "/posts/%E8%89%B2%E5%9F%9F/",
    "categories": "技术, 音视频",
    "tags": "音视频, 渲染",
    "date": "2024-10-13 00:00:00 +0800",
    





    
    "snippet": "",
    "content": ""
  },
  
  {
    "title": "使用 Ollama 本地部署 Deepseek 并集成到 VSCode 中",
    "url": "/posts/deepseek_deploy/",
    "categories": "技术, 大模型",
    "tags": "Ollama, Deepseek",
    "date": "2024-09-06 00:00:00 +0800",
    





    
    "snippet": "什么是 Ollama 和 DeepSeek？OllamaOllama 是一个用于本地部署和管理 AI 模型的工具。它允许开发者在本地环境中运行各种 AI 模型，而无需依赖云端服务。Ollama 提供了简单的命令行接口，使得模型的部署和管理变得非常容易。DeepSeekDeepSeek 是一个基于 AI 的代码补全工具，它能够根据上下文提供智能的代码建议。DeepSeek 支持多种编程语言，并...",
    "content": "什么是 Ollama 和 DeepSeek？OllamaOllama 是一个用于本地部署和管理 AI 模型的工具。它允许开发者在本地环境中运行各种 AI 模型，而无需依赖云端服务。Ollama 提供了简单的命令行接口，使得模型的部署和管理变得非常容易。DeepSeekDeepSeek 是一个基于 AI 的代码补全工具，它能够根据上下文提供智能的代码建议。DeepSeek 支持多种编程语言，并且可以通过 API 集成到各种开发环境中，如 VSCode、IntelliJ IDEA 等。在 macOS 上使用 Ollama 部署 DeepSeek首先，我们需要在 macOS 上安装 Ollama。Ollama 可以通过 Homebrew 进行安装。brew install ollama下载 Deepseek 模型访问 ollama 的 deepseek library选择模型，执行对应的命令。这里使用的是 7b 的默认版本.ollama run deepseek-r1运行成功后就可以对话了。在 VSCode 中集成 DeepSeek集成本地模型执行如下命令，先把本地模型的 server 跑起来ollama serve在 VSCode 的插件库中搜索 Continue，安装后 connect 至本地的 Deepseek 模型即可。集成在线模型在 DeepSeek 开放平台申请 API key，然后在 VSCode 中添加对应的 key 即可。"
  },
  
  {
    "title": "使用 VideoToolbox 完成低延时视频编码",
    "url": "/posts/low_latency_encoding/",
    "categories": "技术, 音视频",
    "tags": "音视频, 编解码",
    "date": "2024-09-06 00:00:00 +0800",
    





    
    "snippet": "Low Latency Pipeline",
    "content": "Low Latency Pipeline"
  },
  
  {
    "title": "Matter 协议介绍",
    "url": "/posts/matter/",
    "categories": "技术, 计算机网络",
    "tags": "智能家居, IoT",
    "date": "2024-03-16 00:00:00 +0800",
    





    
    "snippet": "",
    "content": ""
  },
  
  {
    "title": "在 macOS 上部署 ComfyUI",
    "url": "/posts/ComfyUI_in_macOS/",
    "categories": "技术, 大模型",
    "tags": "大模型, Stable Diffusion",
    "date": "2024-03-13 00:00:00 +0800",
    





    
    "snippet": "ComfyUI 是一个强大且模块化的 Stable Diffusion 图形用户界面（GUI）和后端工具。它提供了一个基于图形、节点和流程图的界面，让您能够设计和执行复杂的稳定扩散工作流程。它有以下特点和功能:  节点/图形/流程图界面：您可以在不需要编写代码的情况下实验和创建复杂的稳定扩散工作流程。  全面支持：ComfyUI 支持 SD1.x、SD2.x、SDXL、稳定视频扩散和稳定级联...",
    "content": "ComfyUI 是一个强大且模块化的 Stable Diffusion 图形用户界面（GUI）和后端工具。它提供了一个基于图形、节点和流程图的界面，让您能够设计和执行复杂的稳定扩散工作流程。它有以下特点和功能:  节点/图形/流程图界面：您可以在不需要编写代码的情况下实验和创建复杂的稳定扩散工作流程。  全面支持：ComfyUI 支持 SD1.x、SD2.x、SDXL、稳定视频扩散和稳定级联。  异步队列系统：优化的队列系统仅重新执行工作流中发生更改的部分。  低 VRAM 支持：使用 --lowvram 选项，即使在 VRAM 少于 3GB 的 GPU 上也可以运行（在 VRAM 较低的 GPU 上会自动启用）。  离线工作：ComfyUI 完全离线工作，不会下载任何内容。  模型支持：可以加载 ckpt、safetensors 和 diffusers 模型/检查点，以及独立的 VAE 和 CLIP 模型。  工作流保存/加载：您可以将工作流保存为 JSON 文件，并从生成的 PNG 文件中加载完整的工作流（包括种子）。我们可以使用 ComfyUI 来方便的生成图片。本机环境:  16 inch MacBook Pro(Apple Silicon M1 Pro )  16GB unified memory  512GB SSD  macOS Sonama 14.4 (23E214)python 环境macOS 自带 python3，为了避免执行命令时手动替换，需要处理一下。$ vim ~/.zshrc// 添加如下三行export PATH=\"/Users/tony/Library/Python/3.9/bin:$PATH\"alias python='python3'alias pip='pip3'$ source ~/.zshrctorch 工具$ pip install --pre torch torchvision torchaudio --extra-index-url https://download.pytorch.org/whl/nightly/cpu代码仓库和模型代码仓库地址：https://github.com/comfyanonymous/ComfyUI.git把模型放在 models/checkpoints 目录切换到 ComfyUI 目录，安装依赖$ pip install -r requirements.txt安装的时候会报如下错误。/Users/tony/Library/Python/3.9/lib/python/site-packages/urllib3/__init__.py:35: NotOpenSSLWarning: urllib3 v2 only supports OpenSSL 1.1.1+, currently the 'ssl' module is compiled with 'LibreSSL 2.8.3'. See: https://github.com/urllib3/urllib3/issues/3020这说明 openssl 的编译版本有问题，需要把 LibreSSL 降级$ openssl versionLibreSSL 3.3.6$ pip install urllib3==1.26.6运行$ python main.py --force-fp16Total VRAM 16384 MB, total RAM 16384 MBForcing FP16.Set vram state to: SHAREDDevice: mpsVAE dtype: torch.float32Using sub quadratic optimization for cross attention, if you have memory or speed issues try using: --use-split-cross-attentionStarting serverTo see the GUI go to: http://127.0.0.1:8188  macOS Ventura 可以正常生成图片。macOS Sonoma 14.4 (23E214) 的 GPU 加速会失效，导致生成纯色图像。可以通过增加参数 -cpu 解决，缺点是生成图片会变慢。参考资料  comfyanonymous/ComfyUI  Accelerated PyTorch training on Mac  ImportError: urllib3 v2.0 only supports OpenSSL 1.1.1+, currently the ‘ssl’ module is compiled with LibreSSL 2.8.3  ComfyUI outputs Rothko-esque solid color images"
  },
  
  {
    "title": "一道算法综合题",
    "url": "/posts/path_with_minimum_effort/",
    "categories": "技术, 数据结构与算法",
    "tags": "leetcode, 数据结构与算法, DFS, BFS, UnionFind, Dijkstra",
    "date": "2023-10-25 00:00:00 +0800",
    





    
    "snippet": "题目描述You are a hiker preparing for an upcoming hike. You are given heights, a 2D array of size rows x columns, where heights[row][col] represents the height of cell (row, col). You are situated in t...",
    "content": "题目描述You are a hiker preparing for an upcoming hike. You are given heights, a 2D array of size rows x columns, where heights[row][col] represents the height of cell (row, col). You are situated in the top-left cell, (0, 0), and you hope to travel to the bottom-right cell, (rows-1, columns-1) (i.e., 0-indexed). You can move up, down, left, or right, and you wish to find a route that requires the minimum effort.A route’s effort is the maximum absolute difference in heights between two consecutive cells of the route.Return the minimum effort required to travel from the top-left cell to the bottom-right cell.  Example 1:Input: heights = [[1,2,2],[3,8,2],[5,3,5]]Output: 2Explanation: The route of [1,3,5,3,5] has a maximum absolute difference of 2 in consecutive cells.This is better than the route of [1,2,2,2,5], where the maximum absolute difference is 3.Binary SearchDFS/BFS 判断给定 threshold 是否可行，二分搜索确定最小值。BFSclass Solution {private:    int m, n;    int dir[4][2] = { {0, 1}, {0, -1}, {1, 0}, {-1, 0} };public:    int minimumEffortPath(vector&lt;vector&lt;int&gt;&gt;&amp; heights) {        m = heights.size();        n = m &gt; 0 ? heights[0].size() : 0;        int left = 0, right = 10e6;        int res = -1;        while (left &lt;= right) {            int mid = left + (right - left) / 2;            bool reachable = bfs(heights, mid);            if (reachable) {                res = mid;                right = mid - 1;            }else {                left = mid + 1;            }        }        return left;    }    bool bfs(vector&lt;vector&lt;int&gt;&gt; &amp;heights, int limit) {        queue&lt;pair&lt;int, int&gt;&gt; q;        q.push({0, 0});        vector&lt;vector&lt;bool&gt;&gt; vis(m, vector&lt;bool&gt;(n, false));        vis[0][0] = true;        while (!q.empty()) {            int x = q.front().first, y = q.front().second;            q.pop();            if (x == m - 1 &amp;&amp; y == n - 1) {                return true;            }            for (int i = 0; i &lt; 4; i++) {                int new_x = x + dir[i][0];                int new_y = y + dir[i][1];                if (new_x &gt;= 0 &amp;&amp; new_y &gt;= 0 &amp;&amp; new_x &lt; m &amp;&amp; new_y &lt; n &amp;&amp; !vis[new_x][new_y] &amp;&amp; abs(heights[new_x][new_y] - heights[x][y]) &lt;= limit) {                    q.push({new_x, new_y});                    vis[new_x][new_y] = true;                }            }        }        return false;    }}DFSclass Solution {private:    int m, n;    int dir[4][2] = { {0, 1}, {0, -1}, {1, 0}, {-1, 0} };public:    int minimumEffortPath(vector&lt;vector&lt;int&gt;&gt;&amp; heights) {        m = heights.size();        n = m &gt; 0 ? heights[0].size() : 0;        vector&lt;vector&lt;bool&gt;&gt; vis(m, vector&lt;bool&gt;(n, false));        int left = 0, right = 10e6;        while (left &lt; right) {            int mid = left + (right - left) / 2;            for (int i = 0; i &lt; m; i++) {                std::fill(vis[i].begin(), vis[i].end(), false);            }            dfs(heights, 0, 0, mid, vis);            if (vis[m - 1][n - 1]) {                right = mid;            }else {                left = mid + 1;            }        }        return left;    }    void dfs(vector&lt;vector&lt;int&gt;&gt; &amp;heights, int x, int y, int threshold, vector&lt;vector&lt;bool&gt;&gt; &amp;vis) {        if (x &lt; 0 || y &lt; 0 || x &gt;= m || y &gt;= n || vis[x][y]) {            return;        }        vis[x][y] = true;        for (int i = 0; i &lt; 4; i++) {            int new_x = x + dir[i][0];            int new_y = y + dir[i][1];            if (new_x &lt; 0 || new_y &lt; 0 || new_x &gt;= m || new_y &gt;= n || vis[new_x][new_y]) {                continue;            }            if (abs(heights[new_x][new_y] - heights[x][y]) &gt; threshold) {                continue;            }            dfs(heights, new_x, new_y, threshold, vis);        }    }};UnionFindclass UnionFind {private:    vector&lt;int&gt; pa;    int count;public:    UnionFind(int n):pa(n), count(n) {        for (int i = 0; i &lt; n; i++) {            pa[i] = i;        }    }    int root(int x) {        return x == pa[x] ? x : pa[x] = root(pa[x]);    }    void uni(int x, int y) {        int px = root(x);        int py = root(y);        if (px != py) {            pa[px] = py;            count--;        }    }    bool connected(int x, int y) {        return root(x) == root(y);    }};struct Edge {    int x, y;    int d;    Edge(int _x, int _y, int _d): x(_x), y(_y), d(_d) {};    bool operator &lt; (const Edge &amp;other) const {        return d &gt; other.d;    }};class Solution {public:    int minimumEffortPath(vector&lt;vector&lt;int&gt;&gt;&amp; heights) {        int m = heights.size();        int n = heights[0].size();        priority_queue&lt;Edge&gt; edges;        for (int i = 0; i &lt; m; i++) {            for (int j = 0; j &lt; n; j++) {                int id = i * n + j;                if (i &gt; 0) {                    edges.push(Edge(id - n, id, abs(heights[i][j] - heights[i - 1][j])));                }                if (j &gt; 0) {                    edges.push(Edge(id - 1, id, abs(heights[i][j] - heights[i][j - 1])));                }            }        }        UnionFind uf(m * n);        int res = 0;        while (!edges.empty()) {            Edge e = edges.top();            edges.pop();            uf.uni(e.x, e.y);            if (uf.connected(0, m * n - 1)) {                res = e.d;                break;            }        }        return res;    }};Dijkstrastruct Node {    int x, y;    int limit;    Node(int _x, int _y, int _limit) : x(_x), y(_y), limit(_limit) {}    bool operator &lt; (const Node &amp;other) const {        return limit &gt; other.limit;    }};class Solution {private:    int dirs[4][2] = { {0, 1}, {0, -1}, {1, 0}, {-1, 0} };public:    int minimumEffortPath(vector&lt;vector&lt;int&gt;&gt;&amp; heights) {        int m = heights.size(), n = m &gt; 0 ? heights[0].size() : 0;        vector&lt;vector&lt;bool&gt;&gt; vis(m, vector&lt;bool&gt;(n, false));        priority_queue&lt;Node&gt; pq;        pq.emplace(Node(0, 0, 0));        vector&lt;int&gt; dist(m * n, INT_MAX);        dist[0] = 0;        while (!pq.empty()) {            Node node = pq.top();            pq.pop();            int x = node.x, y = node.y, limit = node.limit;            if (vis[x][y]) {                continue;            }            if (x == m - 1 &amp;&amp; y == n - 1) {                break;            }            vis[x][y] = true;            for (int i = 0; i &lt; 4; i++) {                int nx = x + dirs[i][0];                int ny = y + dirs[i][1];                if (nx &lt; 0 || ny &lt; 0 || nx &gt;= m || ny &gt;= n) {                    continue;                }                int new_limit = max(limit, abs(heights[nx][ny] - heights[x][y]));                if (new_limit &gt;= dist[nx * n + ny]) {                    continue;                }                dist[nx * n + ny] = new_limit;                pq.emplace(Node(nx, ny, new_limit));                            }        }        return dist.back();    }};"
  },
  
  {
    "title": "香港之行",
    "url": "/posts/travel_hongkong/",
    "categories": "生活, 旅游",
    "tags": "生活, 旅游",
    "date": "2023-06-14 00:00:00 +0800",
    





    
    "snippet": "前言近两年经济形势非常不好，各地都在推出刺激经济的政策。香港政府联合香港的多家航空公司，推出了“飞遇世界大赏”的活动。4 月底，我恰好抽中了北京往返香港的机票，所以香港之行就顺理成章的提上日程了。港澳台通行证第一次办港澳通行证，搜了一些资料。最终发现只需要三步就可以：  在北京市公安局官网预申请，预申请成功后会收到一条短信  收到包含预申请查询密码的短信后，登录北京市公安局官网，再预约现场办...",
    "content": "前言近两年经济形势非常不好，各地都在推出刺激经济的政策。香港政府联合香港的多家航空公司，推出了“飞遇世界大赏”的活动。4 月底，我恰好抽中了北京往返香港的机票，所以香港之行就顺理成章的提上日程了。港澳台通行证第一次办港澳通行证，搜了一些资料。最终发现只需要三步就可以：  在北京市公安局官网预申请，预申请成功后会收到一条短信  收到包含预申请查询密码的短信后，登录北京市公安局官网，再预约现场办理的时间  拿上身份证，如果是非京籍的话，需要带上工作居住证，前往就近的派出所即可办理  现场办理需要穿深色衣服，否则会被要求换上派出所提供的巨丑深色衬衫香港地理区域介绍香港特别行政区由香港岛、九龙半岛、新界及离岛四个主要区域组成，下面是各个主要区域及其子区域的介绍：  香港岛：香港的商业、政治和文化中心，包括中西区、湾仔区、东区、南区和油尖旺区等子区域。  九龙半岛：香港的繁华商业区，包括油麻地、旺角、尖沙咀等子区域。  新界：香港的北部和东部地区，包括元朗、屯门、大埔、沙田、葵青等子区域。  离岛：香港的离岛群岛，包括大澳、长洲、赤鱲角等子区域。交通因为是抽中的机票，所以只需要付燃油和税费就好，额度根据政策和汇率不同会有所浮动。这次我额外付的费用大概 616 元人民币。顺便搜索了 6 月 9 日北京飞香港的航班，最低是东航的，价格在 600 出头，含税费。所以其实这次交通费也就节约了 600 元左右的机票钱。香港本地有多种公共交通工具，包括：  地铁（港铁）：香港地铁系统覆盖了香港岛、九龙和新界等地区，是香港最为便捷的交通工具之一。地铁票价根据行程长度而定，从尖沙咀到金钟站，一站地铁，刷支付宝需要 10 港元左右。  公共巴士：香港有多家公共巴士公司，覆盖了香港的各个角落，是香港最常用的交通工具之一。巴士票价根据行程长度而定，一般在 4-20 港元之间。从机场到市区最便宜的选择。  电车：香港北角和西环地区有两条电车路线，是香港历史悠久的交通工具之一。电车票价为 2.6 港元。  出租车：香港的出租车分为红色出租车和绿色出租车两种，覆盖了香港的各个地区。红色出租车票价起步价为 24 港元，绿色出租车票价起步价为 20 港元。支付我带了招行银行香港卡，招商银行全球 VISA 卡，临出发前，我们还在北京的招商银行兑换了 1000 元港币以备不测。实际发现香港的很多地方都支持支付宝和微信支付了，住酒店时刷了 VISA 卡。之前做攻略里有提到八达通，但是我并没有办。中间发现坐船需要八达通，只得改乘地铁。总体而言，支付宝 + 信用卡足以覆盖绝大部分支付场景。住宿第一天到达香港的时候是晚上，订高级酒店不太划算。所以第一天晚上在 Agoda 上订了香港珀丽酒店，价格在 600 元左右。之后我们选择的是万豪国际旗下的 JW 万豪，官网预定价格最低是 2800 左右，不含早餐。在淘宝可以搜索到代订服务，价格 2700 左右，并且有白金会员权益，送行政酒廊待遇。JW 万豪的泳池JW 行政酒廊的时间表关于押金，押金在香港叫按金，押金依据酒店价格会有所不同。退押金的时间和大陆不同，大陆退房后几乎秒退押金，但是在香港，预计需要 2 周到 1 个月才能退。通信支付宝搜索境外流量，按需办理套餐即可。短时间游玩，没有必要办理香港电话卡。进入香港境内自动激活流量套餐，需要注意的是，套餐的时间是按照自然日来算的，而不是激活之后的若干小时。比如你办了两天的套餐，在第一天晚上 10 点到达香港激活，在第二天的午夜 12 点后就会失效，而不是到第 3 天的晚上 10 点。景点香港的地方不大，景点相对于大陆一线城市而言并不多。我们行程比较紧张，所以迪士尼和海洋馆都没去，只在维多利亚港打个卡。随后去了尖沙咀和中环附近的商场，最后去旺角附近的金鱼街和朗豪坊逛了逛，总体比较休闲与佛系。香港大街上有很多“药房”，名为药房，实际上可以理解为免税便利店。有 Rx 标记的是港府授权的，注意甄别。下图中“政府注册”和“免税正货”之间就是 Rx 标记。药房的Rx标记饮食出发前，同事推荐了两家餐厅，分别是华嫂冰室、唐宫小聚，人均分别在 70 港币，200 港币左右。我们分别去了两家吃了早饭和中饭。之后寻找餐厅的方式延续了在大陆的习惯，大众点评上检索排行榜，随后在“添好运”排队了 40 分钟后吃上了港式点心。价格跟大陆一线城市差不多。添好运餐厅的菜单代购与海关之前朋友圈有很多香港代购，印象中过海关时会有严格的排查，实际上我并没有体验到。从北京出发时，安检了两次，分别是机场安检和海关安检。从香港返程时，只有海关安检，机器扫描包裹，并无搜身，落地北京后也没有任何安检。让我有些许疑惑，这走私岂不是很方便？有点后悔没买点贵重物品了哈哈。结语最后谈一谈对香港的印象吧。香港确实是一个国际化的大城市，外国人很多，酒店工作人员也会优先使用英语交流。市区的街道较为狭窄，周边高楼林立，导航在此时的定位不准确，在商场之间穿梭时，容易迷路。奢侈大品牌很多，交通便利，基础设施完善。但是，因为香港的城市化进程较早，所以有些设施比较陈旧。此外，在旺角地铁口附近，我看到了一些流浪汉，以及大量的外籍女性在过街天桥上过夜。香港的房价太高，所以这座城市的很多底层人民过的其实有点凄惨。这种景象我在北京和上海都没有见到过。任何地方都既有光鲜的一面，也有阴暗的角落。香港也不例外。"
  },
  
  {
    "title": "App 的本质和 Mach-O 文件",
    "url": "/posts/app_mach_o/",
    "categories": "技术, iOS",
    "tags": "macOS, iOS, 操作系统",
    "date": "2023-06-01 00:00:00 +0800",
    





    
    "snippet": "进程App 的本质是一个可执行程序，是一段计算机代码和数据的集合。从操作系统的角度来看，App 的本质是一个进程。进程是计算机中正在运行的程序的实例。在操作系统中，进程是操作系统分配资源和调度执行的基本单位。每个进程都有自己的内存空间、寄存器集合、文件句柄、网络连接等资源，它们可以独立地运行和被管理。进程是操作系统中最基本的资源分配和调度单位。操作系统通过进程控制块 PCB(Process ...",
    "content": "进程App 的本质是一个可执行程序，是一段计算机代码和数据的集合。从操作系统的角度来看，App 的本质是一个进程。进程是计算机中正在运行的程序的实例。在操作系统中，进程是操作系统分配资源和调度执行的基本单位。每个进程都有自己的内存空间、寄存器集合、文件句柄、网络连接等资源，它们可以独立地运行和被管理。进程是操作系统中最基本的资源分配和调度单位。操作系统通过进程控制块 PCB(Process Control Block) 来管理进程，PCB 包含了进程的状态、进程 ID、进程优先级、内存使用情况、文件句柄等信息。当操作系统需要切换到另一个进程时，它会保存当前进程的上下文，然后加载另一个进程的上下文，从而实现进程之间的切换。在 macOS 中，PCB 被称为 proc。proc 结构体是 macOS 内核中非常重要的数据结构，用于描述进程在内核中的状态和信息。struct proc {    LIST_ENTRY(proc) p_list;                /* List of all processes. */    void *          XNU_PTRAUTH_SIGNED_PTR(\"proc.task\") task;       /* corresponding task (static)*/    struct  proc *  XNU_PTRAUTH_SIGNED_PTR(\"proc.p_pptr\") p_pptr;   /* Pointer to parent process.(LL) */    pid_t           p_ppid;                 /* process's parent pid number */    pid_t           p_original_ppid;        /* process's original parent pid number, doesn't change if reparented */    pid_t           p_pgrpid;               /* process group id of the process (LL)*/    uid_t           p_uid;    gid_t           p_gid;    uid_t           p_ruid;    gid_t           p_rgid;    uid_t           p_svuid;    gid_t           p_svgid;    uint64_t        p_uniqueid;             /* process unique ID - incremented on fork/spawn/vfork, remains same across exec. */    uint64_t        p_puniqueid;            /* parent's unique ID - set on fork/spawn/vfork, doesn't change if reparented. */    lck_mtx_t       p_mlock;                /* mutex lock for proc */    pid_t           p_pid;                  /* Process identifier. (static)*/    char            p_stat;                 /* S* process status. (PL)*/    char            p_shutdownstate;    char            p_kdebug;               /* P_KDEBUG eq (CC)*/    char            p_btrace;               /* P_BTRACE eq (CC)*/    /* 以下其他字段已省略 */};proc 包含了大量的字段和指针，用于描述进程的各种属性和资源使用情况，例如进程状态（p_stat）、进程 ID（p_pid）、进程名称（p_comm）、进程优先级（p_priority）、进程内存使用情况（p_vmspace）、文件描述符表（p_fd）、线程列表（p_threadlist）等。Mach-O 文件在 App 加载到内存成为进程之前，macOS 上的可执行文件是 Mach-O 文件。Mach-O 文件包含了可执行代码、数据、符号表、动态链接信息等多个部分，是 macOS 中应用程序和库文件的基本格式。Mach-O 文件的格式可以分为文件头（Header）、加载命令（Load commands）和数据区（Raw segment data）三个部分。Mach-O file包含多个 CPU 架构的 Mach-O 文件被称为 Fat Binary。可以通过 file 命令查看 Mach-O 文件的 CPU 架构。$ file /System/Applications/Calculator.app/Contents/MacOS/Calculator/System/Applications/Calculator.app/Contents/MacOS/Calculator: Mach-O universal binary with 2 architectures: [x86_64:Mach-O 64-bit executable x86_64] [arm64e:Mach-O 64-bit executable arm64e]/System/Applications/Calculator.app/Contents/MacOS/Calculator (for architecture x86_64):\tMach-O 64-bit executable x86_64/System/Applications/Calculator.app/Contents/MacOS/Calculator (for architecture arm64e):\tMach-O 64-bit executable arm64eFat Binary 对应的 fat_header 在操作系统中的数据结构定义是 fat_header。struct fat_header {\tuint32_t\tmagic;\t\t/* FAT_MAGIC */\tuint32_t\tnfat_arch;\t/* number of structs that follow */};// Fat Binary 包含了多个 fat_arch 组成的 Mach-O 文件struct fat_arch {\tcpu_type_t\tcputype;\t/* cpu specifier (int) */\tcpu_subtype_t\tcpusubtype;\t/* machine specifier (int) */\tuint32_t\toffset;\t\t/* file offset to this object file */\tuint32_t\tsize;\t\t/* size of this object file */\tuint32_t\talign;\t\t/* alignment as a power of 2 */};可以看到，macOS 系统的计算器程序 Mach-O 文件，是包含了 x86_64 和 arm64e 两种 CPU 架构的 Fat Binary。  iOS 系统自 iOS 11.0 版本以后，不再支持 armv7，armv7s 等架构，只支持 arm64 架构。所以仅支持 iOS 11.0 以后版本的项目，打包产物的 Fat Binary 只有 arm64 架构的 Mach-O 文件。这也是 Xcode 14.0 取消了 bitcode 的原因，因为不再需要编译成 bitcode 中间产物，且 bitcode 转译会消耗 AppStore 的服务器资源文件头（haeder）Mach-O 文件头包含了文件类型、CPU 类型、加载命令数量等信息。Mach-O 文件支持多种文件类型，包括可执行文件、动态链接库、框架等。CPU 类型指定了可执行文件适用的 CPU 架构，例如 x86、x86_64、armv7、arm64 等。加载命令数量指定了文件中包含的加载命令数量。otool 命令是 macOS 和 iOS 等操作系统上的一个工具，用于查看可执行文件、动态库和框架等二进制文件的信息。它可以用来查看二进制文件的头部信息、节表、符号表、动态链接信息等。$ otool -h /System/Applications/Calculator.app/Contents/MacOS/Calculator/System/Applications/Calculator.app/Contents/MacOS/Calculator:Mach header      magic  cputype cpusubtype  caps    filetype ncmds sizeofcmds      flags 0xfeedfacf 16777228          2  0x80           2    29       4208 0x00200085除了 otools 命令，还可以使用 MachOView 工具通过图形化页面来查看 Mach-O 文件brew install machoviewMachOViewFat Binary 中，每个架构都有一个 header 文件头，被称为 mach_header。64 位架构的 mach_header 会多一个保留字段。/* * The 32-bit mach header appears at the very beginning of the object file for * 32-bit architectures. */struct mach_header {\tuint32_t\tmagic;\t\t/* mach magic number identifier */\tcpu_type_t\tcputype;\t/* cpu specifier */\tcpu_subtype_t\tcpusubtype;\t/* machine specifier */\tuint32_t\tfiletype;\t/* type of file */\tuint32_t\tncmds;\t\t/* number of load commands */\tuint32_t\tsizeofcmds;\t/* the size of all the load commands */\tuint32_t\tflags;\t\t/* flags */};/* Constant for the magic field of the mach_header (32-bit architectures) */#define\tMH_MAGIC\t0xfeedface\t/* the mach magic number */#define MH_CIGAM\t0xcefaedfe\t/* NXSwapInt(MH_MAGIC) *//* * The 64-bit mach header appears at the very beginning of object files for * 64-bit architectures. */struct mach_header_64 {\tuint32_t\tmagic;\t\t/* mach magic number identifier */\tcpu_type_t\tcputype;\t/* cpu specifier */\tcpu_subtype_t\tcpusubtype;\t/* machine specifier */\tuint32_t\tfiletype;\t/* type of file */\tuint32_t\tncmds;\t\t/* number of load commands */\tuint32_t\tsizeofcmds;\t/* the size of all the load commands */\tuint32_t\tflags;\t\t/* flags */\tuint32_t\treserved;\t/* reserved */};/* Constant for the magic field of the mach_header_64 (64-bit architectures) */#define MH_MAGIC_64 0xfeedfacf /* the 64-bit mach magic number */#define MH_CIGAM_64 0xcffaedfe /* NXSwapInt(MH_MAGIC_64) */加载命令（Load commands）Mach-O 文件中的加载命令（Load Command）用于描述可执行文件的各个段的属性和位置等信息，操作系统会根据这些信息将可执行文件加载到内存中。每个 Load Command 描述了一个特定的段或区域。常见的 Load Command 包括：  LC_SEGMENT 和 LC_SEGMENT_64：描述可执行代码和数据的段信息；  LC_SYMTAB 和 LC_DYSYMTAB：描述符号表和动态符号表信息；  LC_LOAD_DYLIB 和 LC_LOAD_WEAK_DYLIB：描述动态链接库的信息；  LC_MAIN：描述程序入口点的信息。load_commandstruct load_command {\tuint32_t cmd;\t\t/* type of load command */\tuint32_t cmdsize;\t/* total size of command in bytes */};数据区（Raw segment data）Mach-O 文件的数据区包含了多个段（Segment），每个段包含了不同类型的数据。常见的段包括 __TEXT、__DATA、__LINKEDIT 等。其中，__TEXT 段包含了代码和只读数据，__DATA 段包含了全局变量和静态变量等数据，__LINKEDIT 段包含了符号表和重定位信息等。segmentstruct segment_command_64 { /* for 64-bit architectures */\tuint32_t\tcmd;\t\t/* LC_SEGMENT_64 */\tuint32_t\tcmdsize;\t/* includes sizeof section_64 structs */\tchar\t\tsegname[16];\t/* segment name */\tuint64_t\tvmaddr;\t\t/* memory address of this segment */\tuint64_t\tvmsize;\t\t/* memory size of this segment */\tuint64_t\tfileoff;\t/* file offset of this segment */\tuint64_t\tfilesize;\t/* amount to map from the file */\tint32_t\t\tmaxprot;\t/* maximum VM protection */\tint32_t\t\tinitprot;\t/* initial VM protection */\tuint32_t\tnsects;\t\t/* number of sections in segment */\tuint32_t\tflags;\t\t/* flags */};在 Mach-O 文件中，每个 Segment 包含一个或多个 section，每个 section 包含了一组相关的数据或代码。例如，在一个可执行文件中，常见的 Segment 包括 __TEXT、__DATA、__LINKEDIT 等，每个 Segment 包含了多个 section，例如 __TEXT 包含了 __text、__cstring、__stub 等多个 section。Section 是 Mach-O 文件中的一个子单元，它是 Segment 中的一个子段，包含了一组相关的数据或代码。每个 Section 都有一个名称和一个类型，例如 __text、__data、__cstring 等。在 Mach-O 文件中，Section 的名称和类型通常与编译器和链接器相关，不同的编译器和链接器可能会使用不同的名称和类型。struct section_64 { /* for 64-bit architectures */\tchar\t\tsectname[16];\t/* name of this section */\tchar\t\tsegname[16];\t/* segment this section goes in */\tuint64_t\taddr;\t\t/* memory address of this section */\tuint64_t\tsize;\t\t/* size in bytes of this section */\tuint32_t\toffset;\t\t/* file offset of this section */\tuint32_t\talign;\t\t/* section alignment (power of 2) */\tuint32_t\treloff;\t\t/* file offset of relocation entries */\tuint32_t\tnreloc;\t\t/* number of relocation entries */\tuint32_t\tflags;\t\t/* flags (section type and attributes)*/\tuint32_t\treserved1;\t/* reserved (for offset or index) */\tuint32_t\treserved2;\t/* reserved (for count or sizeof) */\tuint32_t\treserved3;\t/* reserved */};参考资料  Mach-O Programming Topics  osx-abi-macho-file-format-reference  深入剖析Macho  ChatGPT"
  },
  
  {
    "title": "HLS 协议介绍",
    "url": "/posts/hls_intro/",
    "categories": "技术, 音视频",
    "tags": "HLS, 音视频",
    "date": "2022-05-27 00:00:00 +0800",
    





    
    "snippet": "HLS 协议HLS 是 HTTP Live Streaming 的缩写，是由苹果公司提出的基于 HTTP 的流媒体网络传输协议，它可以同时支持直播和点播，还支持多清晰度、音视频双轨、字幕等功能。 它的原理是将一整条视频分成多段小的视频，完整的播放是由这一个个片段拼接而成的。HLS 协议规定：  视频的封装格式是 TS。  视频的编码格式为 H264，音频编码格式为 MP3、AAC或者 AC-...",
    "content": "HLS 协议HLS 是 HTTP Live Streaming 的缩写，是由苹果公司提出的基于 HTTP 的流媒体网络传输协议，它可以同时支持直播和点播，还支持多清晰度、音视频双轨、字幕等功能。 它的原理是将一整条视频分成多段小的视频，完整的播放是由这一个个片段拼接而成的。HLS 协议规定：  视频的封装格式是 TS。  视频的编码格式为 H264，音频编码格式为 MP3、AAC或者 AC-3。  除了 TS 视频文件本身，还定义了用来控制播放的 m3u8 文件（文本文件）优点:  解决特殊情况下的防火墙屏蔽  服务器拓展方便。RTMP 是一种有状态协议，很难对视频服务器进行平滑扩展，因为需要为每一个播放视频流的客户端维护状态。而 HLS 基于无状态协议（HTTP），客户端只是按照顺序使用下载存储在服务器的普通 TS 文件，做负责均衡如同普通的 HTTP 文件服务器的负载均衡一样简单  码率自适应缺点:  直播场景的延迟高（录播无延迟影响）  大量的 TS 片文件，会造成服务器存储和请求的压力采集端流程HLS直播流程  AVInputs采集音视频源  Server服务器组件负责获取的媒体输入流 , 然后Media编码后 MPEG-4（H.264 video 和 AAC audio）格式然后用硬件打包到 MPEG-2 (MPEG-2 transport stream)的传输流中。图中显示,传输流会经过 stream segmenter, 这里的工作是 MPEG-2 传输流会被分散为小片段然后保存为一个或多个系列的 .ts 格式的媒体文件。这个过程需要借助编码工具来完成，比如 Apple stream segmenter。视频是 fmp4 文件（新版）或 ts 文件（老版），纯音频会被编码为一些音频小片段，通常为 ADTS 头的 AAC、MP3、或者 AC-3 格式。服务端可以采用硬件编码和软件编码两种形式，其功能都是按照上文描述的规则对现有的媒体文件进行切片并使用索引文件进行管理。而软件切片通常会使用 Apple 公司提供的工具或者第三方的集成工具。  Distribution提供 HTTP 服务，包含了 Server 创建好的 m3u8 索引和 ts 分片文件  Clients请求 m3u8 资源文件格式HLS 协议包含了两种类型的文件，索引文件和 ts/fMP4 文件索引文件有两种  Index file  Alternate Index fileHLS Indexts 文件每个 ts 文件都由若干个 ts packet 组成，每个 ts packet 包是 188 字节。原因：为了适配 ATM(Asynchronous Transfer Mode) 系统is motivated by the fact that the payload of the ATM Adaptation Layer-1 (AAL-1) cell is 47 bytes. Therefore, four AAL-1 cells can accommodate a single TS packet.HLS TSfMP4HLS fMP4在 EXT-X-VERSION 7 支持了fMP4.fMP4 是基于 MPEG-4 Part 12 的流媒体格式，与 mp4 很相似，但也有一些区别，fMP4 更好的适应流式播的需求.fMP4 可以支持 h.265，能够大大节省带宽，已经慢慢变成现在的视频主流，尤其是视频监控领域。播放模式      点播当前时间点可以获取到所有 index 文件和 ts 文件，二级 index 文件中记录了所有 ts 文件的地址。这种模式允许客户端访问全部内容。上面的例子中就是一个点播模式下的 m3u8 的结构。        直播实时生成 M3U8 和 ts 文件。它的索引文件一直处于动态变化的，播放的时候需要不断下载二级 index 文件，以获得最新生成的 ts 文件播放视频。如果一个二级 index 文件的末尾没有 #EXT-X-ENDLIST 标志，说明它是一个 Live 视频流  安全性加密信息：#EXT-X-KEY:METHOD=AES-128,URI=”xx.key”,IV=xxxFairPlay StreamingFairPlay Streaming is:  A secure key delivery mechanism Content Key is protected on the network and on the client during playback  Key delivery is transport agnostic Easy to integrate with existing key server infrastructure  Requires protected HDMI for external output流程HLS Fair Play推流 DemoConceptually, HTTP Live Streaming consists of three parts: the server component, the distribution component, and the client software.In a typical configuration, a hardware encoder takes audio-video input, encodes it as HEVC video and AC-3 audio, and outputs a fragmented MPEG-4 file or an MPEG-2 transport stream. A software stream segmenter then breaks the stream into a series of short media files, which are placed on a web server. The segmenter also creates and maintains an index file containing a list of the media files. The URL of the index file is published on the web server. Client software reads the index, then requests the listed media files in order and displays them without any pauses or gaps between segments.下载工具下载地址: https://developer.apple.com/download/all/?q=HLS安装完发现有个 go 的 exampleHLS Go Serverbrew install go，安装 go，然后启动该服务# tony @ tonyMBP in ~/Desktop/hls_server [14:48:18]$ go run ll-hls-origin-example.goll-hls-origin-example.go:43:2: no required module provides package github.com/fsnotify/fsnotify: go.mod file not found in current directory or any parent directory; see 'go help modules'# tony @ tonyMBP in ~/Desktop/hls_server [14:48:25] C:1$ go mod init hls_servergo: creating new go.mod: module hls_servergo: to add module requirements and sums:        go mod tidy                # tony @ tonyMBP in ~/Desktop/hls_server [14:49:23]$ go buildll-hls-origin-example.go:43:2: no required module provides package github.com/fsnotify/fsnotify; to add it:        go get github.com/fsnotify/fsnotify                # tony @ tonyMBP in ~/Desktop/hls_server [14:49:28] C:1$ go get github.com/fsnotify/fsnotifygo: downloading github.com/fsnotify/fsnotify v1.5.4go: downloading golang.org/x/sys v0.0.0-20220412211240-33da011f77adgo: added github.com/fsnotify/fsnotify v1.5.4go: added golang.org/x/sys v0.0.0-20220412211240-33da011f77ad# tony @ tonyMBP in ~/Desktop/hls_server [14:49:48]$ go run ll-hls-origin-example.goListening on http://:8443/启动 mediastreamsegmenter 服务$ mediastreamsegmenter -w 499 -t 1 224.0.0.50:9121 -s 16 -D -T -f ~/Desktop/hls_server/hls使用 ffmpeg 推流既可以使用系统内置摄像头采集音视频，也可以指定本地视频文件。使用 mac 内置采集设备$ ffmpeg -f avfoundation -list_devices true -i \"\"[AVFoundation indev @ 0x7f924d904400] AVFoundation video devices:[AVFoundation indev @ 0x7f924d904400] [0] FaceTime高清摄像头（内建）[AVFoundation indev @ 0x7f924d904400] [1] Capture screen 0[AVFoundation indev @ 0x7f924d904400] AVFoundation audio devices:[AVFoundation indev @ 0x7f924d904400] [0] LarkAudioDevice[AVFoundation indev @ 0x7f924d904400] [1] 外置麦克风[AVFoundation indev @ 0x7f924d904400] [2] MacBook Pro麦克风  $ ffmpeg -f avfoundation -framerate 30 -pixel_format uyvy422 -i \"0:\" -c:v h264 -fflags nobuffer -tune zerolatency -f mpegts udp://192.168.1.5:9121使用指定文件$ ffmpeg -re -i \"/Users/tony/Downloads/sample.mp4\" -c:v h264 -fflags nobuffer -tune zerolatency -f mpegts udp://192.168.1.5:9121疑难问题  seek 不准确如何解决？mp4 可以 seek 到指定的时间戳， ts 是 seek 到文件的某个 position，而不能直接 seek 到指定的时间点。在 ffplay.c 中的 event_loop 函数中包含了 seek 的相关代码。对于 ts，具体 seek 操作调用函数关系为 avformat_seek_file()=&gt; av_seek_frame() =&gt; seek_frame_internal() =&gt; seek_frame_byte()对于 mp4，具体 seek 操作调用函数关系为 avformat_seek_file()=&gt; av_seek_frame() =&gt; seek_frame_internal() =&gt;mov_read_seek()ts seek 逻辑是: 给定一个文件位置，直接将文件指针指向该位置。接下来调用 read_packet() 读取一个 ts 包(188字节)时，由于之前进行了 seek 操作，文件指针很可能没有指到一个 ts packet 的包头位置（包头以 0x47 byte 打头的），这时候需要调用 mpegts_resync() 进行重新同步找到包头，然后再重新读取一个完整 ts packet。mp4 的 seek 操作逻辑是：给定一个 seek 的目标时间戳(timestamp)，根据 mp4 里每个包的索引信息，找到时间戳对应的包就可以了。根据下面的 mp4 的文件组织结构，利用Sample Table，可以快速找到任意给定时间戳的 video audio 数据包。结论  对 mp4 文件来说，由于有索引表，可以快速找到某个时间戳所对应的数据，所以 seek 操作可以快速完成。  ts 文件没有时间戳和数据包位置的对应关系，所以对播放器来说，给定 seek 的时间戳 ts_seek，首先应该根据文件的码率估算一个位置 pos，然后获取该位置的数据包的时间戳 ts_actual，如果 ts_actual &lt; ts_seek ，则需要继续往后读取数据包；如果t s_actual&gt; ts_seek，则需要往前读取数据包，直到读到 ts_seek 对应的数据包。所以 ts 文件的操作可能更加耗时； 如果 ts 包含的是 CBR 码流，则 ts_actual 与 ts_seek 一般差别不大， seek 相对较快； 如果 ts 包含的 VBR 码流， 则 ts_actual 与 ts_seek 可能相差甚远， 则 seek 相对较慢。HLS Seek  不同分辨率的 ts/fMP4 文件的兼容性问题安卓端在播放 m3u8 视频时，遇到了花屏问题。查明原因是 ts 分辨率改变这个是必须加上 hevc_mp4toannexb，原始协议只支持 h264_mp4toannexbH.264/5 码流分 Annex-B 和 AVCC 两种格式,AVCC 以长度信息分割 NALU，在 mp4 和 flv 等封装格式中使用。Annex-B 以 start code(0x000001或0x00000001) 分割 NALU，在 mpegts 流媒体文件中使用加上 hevc_mp4toannexb 后每一帧都能解析出视频宽高，这样不会有切换花屏问题。参考资料  https://developer.apple.com/documentation/http_live_streaming/understanding_the_http_live_streaming_architecture  https://en.wikipedia.org/wiki/MPEG_transport_stream  http://anddymao.com/2021/08/03/2021-08-03-%E4%B8%80%E7%A7%8D%E4%B8%87%E8%83%BDhls%E5%8D%8F%E8%AE%AE%E8%A7%A3%E6%9E%90%E6%96%B9%E6%B3%95/"
  },
  
  {
    "title": "FFmpeg 简介",
    "url": "/posts/ffmpeg_intro/",
    "categories": "技术, 音视频",
    "tags": "FFmpeg, 音视频",
    "date": "2022-05-25 00:00:00 +0800",
    





    
    "snippet": "FFmpeg 的定义FFmpeg 既是一款音视频编解码工具，也是一组音视频编解码开发套件。FFmpeg 支持多种协议，提供了多种多媒体格式的封装和解封装，音视频的编码、解码，采样率转换，码率转换，色彩格式转换等丰富的功能。FF: fast forwordmpeg: Moving Picture Experts Group音视频其他概念  协议：如 HLS，rtsp  封装格式：如 mov，m...",
    "content": "FFmpeg 的定义FFmpeg 既是一款音视频编解码工具，也是一组音视频编解码开发套件。FFmpeg 支持多种协议，提供了多种多媒体格式的封装和解封装，音视频的编码、解码，采样率转换，码率转换，色彩格式转换等丰富的功能。FF: fast forwordmpeg: Moving Picture Experts Group音视频其他概念  协议：如 HLS，rtsp  封装格式：如 mov，mp4，mkv，rmvb。一个视频文件可以封装多组音视频编码流  编码格式：视频编码如 H.264，HEVC(H.265)，音频编码如 mp3，aac，G.711，opusFFmpeg 的使用在 macOS 平台上，可以使用 homebrew 安装 ffmpeg 的可执行文件$ brew install ffmpeg$ ffmpeg -versionffmpeg version 5.1.2 Copyright (c) 2000-2022 the FFmpeg developersbuilt with Apple clang version 14.0.0 (clang-1400.0.29.202)configuration: --prefix=/opt/homebrew/Cellar/ffmpeg/5.1.2_6 --enable-shared --enable-pthreads --enable-version3 --cc=clang --host-cflags= --host-ldflags= --enable-ffplay --enable-gnutls --enable-gpl --enable-libaom --enable-libaribb24 --enable-libbluray --enable-libdav1d --enable-libmp3lame --enable-libopus --enable-librav1e --enable-librist --enable-librubberband --enable-libsnappy --enable-libsrt --enable-libsvtav1 --enable-libtesseract --enable-libtheora --enable-libvidstab --enable-libvmaf --enable-libvorbis --enable-libvpx --enable-libwebp --enable-libx264 --enable-libx265 --enable-libxml2 --enable-libxvid --enable-lzma --enable-libfontconfig --enable-libfreetype --enable-frei0r --enable-libass --enable-libopencore-amrnb --enable-libopencore-amrwb --enable-libopenjpeg --enable-libspeex --enable-libsoxr --enable-libzmq --enable-libzimg --disable-libjack --disable-indev=jack --enable-videotoolbox --enable-neonlibavutil      57. 28.100 / 57. 28.100libavcodec     59. 37.100 / 59. 37.100libavformat    59. 27.100 / 59. 27.100libavdevice    59.  7.100 / 59.  7.100libavfilter     8. 44.100 /  8. 44.100libswscale      6.  7.100 /  6.  7.100libswresample   4.  7.100 /  4.  7.100libpostproc    56.  6.100 / 56.  6.100一个简单的例子$ ffmpeg -i input.mp4 output.aviInput #0, mov,mp4,m4a,3gp,3g2,mj2, from 'input.mp4':  Metadata:    major_brand     : isom    minor_version   : 512    compatible_brands: isomiso2avc1mp41    encoder         : Lavf58.76.100  Duration: 00:00:07.62, start: 0.000000, bitrate: 13805 kb/s  Stream #0:0(und): Video: h264 (High) (avc1 / 0x31637661), yuv420p(tv, bt709), 1920x1080, 13679 kb/s, 29.97 fps, 29.97 tbr, 30k tbn, 59.94 tbc (default)    Metadata:      handler_name    : Core Media Video      vendor_id       : [0][0][0][0]  Stream #0:1(und): Audio: aac (LC) (mp4a / 0x6134706D), 44100 Hz, stereo, fltp, 130 kb/s (default)    Metadata:      handler_name    : Core Media Audio      vendor_id       : [0][0][0][0]Stream mapping:  Stream #0:0 -&gt; #0:0 (h264 (native) -&gt; mpeg4 (native))  Stream #0:1 -&gt; #0:1 (aac (native) -&gt; mp3 (libmp3lame))Press [q] to stop, [?] for helpOutput #0, avi, to 'output.avi':  Metadata:    major_brand     : isom    minor_version   : 512    compatible_brands: isomiso2avc1mp41    ISFT            : Lavf58.76.100  Stream #0:0(und): Video: mpeg4 (FMP4 / 0x34504D46), yuv420p(tv, bt709, progressive), 1920x1080, q=2-31, 200 kb/s, 29.97 fps, 29.97 tbn (default)    Metadata:      handler_name    : Core Media Video      vendor_id       : [0][0][0][0]      encoder         : Lavc58.134.100 mpeg4    Side data:      cpb: bitrate max/min/avg: 0/0/200000 buffer size: 0 vbv_delay: N/A  Stream #0:1(und): Audio: mp3 (U[0][0][0] / 0x0055), 44100 Hz, stereo, fltp (default)    Metadata:      handler_name    : Core Media Audio      vendor_id       : [0][0][0][0]      encoder         : Lavc58.134.100 libmp3lameframe=    1 fps=0.0 q=6.9 size=     133kB time=00:00:00.15 bitrate=6965.1kbits/s speed=9.2frame=   94 fps=0.0 q=31.0 size=    2816kB time=00:00:03.26 bitrate=7064.8kbits/s speed=6.frame=  201 fps=197 q=31.0 size=    4864kB time=00:00:06.81 bitrate=5844.3kbits/s speed=6.frame=  228 fps=202 q=31.0 Lsize=    5363kB time=00:00:07.60 bitrate=5775.1kbits/s speed=6.74xvideo:5221kB audio:120kB subtitle:0kB other streams:0kB global headers:0kB muxing overhead: 0.412835%该命令，通过 -i 参数指定 input.mp4 作为输入源，然后进行转码和转封装操作，最后输出到 output.avi 文件。可以看到，input.mp4 的封装格式为 mp4，视频编码为 h.264，音频编码为 aac。output.avi 的封装格式为 avi，视频编码为 mpeg4，音频编码为 mp3。转化的流程图如下： _______              ______________|       |            |              || input |  demuxer   | encoded data |   decoder| file  | ---------&gt; | packets      | -----+|_______|            |______________|      |                                           v                                       _________                                      |         |                                      | decoded |                                      | frames  |                                      |_________| ________             ______________       ||        |           |              |      || output | &lt;-------- | encoded data | &lt;----+| file   |   muxer   | packets      |   encoder|________|           |______________|FFmpeg 中常用的工具主要是 ffmpeg、ffprobe、ffplay。他们分别用户多媒体的编解码工具，内容分析工具和播放器。ffmpeg 常用命令  功能介绍类$ ffmpeg --help$ ffmpeg -codecs$ ffmpeg -encoders$ ffmpeg -decoders$ ffmpeg -filters  转码类    $ ffmpeg -i input.rmvb -vcodec mpeg4 -b:v 200k -r 15 -an output.mp4        封装格式由 rmvb 转成 mp4，视频编码指定为 mpeg4，视频码率指定 200kbit/s，视频帧率指定为 15fps，转码后的文件不包含音频（-an 参数）  ffprobe 常用命令$ ffprobe -show_packets input.flv$ ffprobe -show_format output.mp4# 以 CSV 文档输出 Packets 信息$ ffprobe -of csv -show_packets input.flvffplay 常用命令# 从视频的第 30 秒开始播放，播放 10 秒中的文件$ ffplay -ss 30 -t 10 input.mp4FFmpeg 的基本组成查看 ffmpeg 版本时可以看到，ffmpeg 主要由 8 个模块构成，包括 libavutil，libavcodec，libavformat，libavdevice，libavfilter，libswscale，libswresample，libpostproc。比较老的 ffmpeg 版本还会编译出 libavresample 模块，也是用于对音频原始出具进行重采样的，已被废弃，推荐使用 libswresample 替代。libavutilThe libavutil library is a utility library to aid portable multimedia programminglibswscaleThe libswscale library performs highly optimized image scaling and colorspace and pixel format conversion operations.libswresampleThe libswresample library performs highly optimized audio resampling, rematrixing and sample format conversion operations.libavcodecThe libavcodec library provides a generic encoding/decoding framework and contains multiple decoders and encoders for audio, video and subtitle streams, and several bitstream filters.The shared architecture provides various services ranging from bit stream I/O to DSP optimizations, and makes it suitable for implementing robust and fast codecs as well as for experimentation.libavformatThe libavformat library provides a generic framework for multiplexing and demultiplexing (muxing and demuxing) audio, video and subtitle streams. It encompasses multiple muxers and demuxers for multimedia container formats.It also supports several input and output protocols to access a media resource.libavdeviceThe libavdevice library provides a generic framework for grabbing from and rendering to many common multimedia input/output devices, and supports several input and output devices, including Video4Linux2, VfW, DShow, and ALSA.libavfilterThe libavfilter library provides a generic audio/video filtering framework containing several filters, sources and sinks.参考资料  https://ffmpeg.org/ffmpeg.html  https://blog.csdn.net/leixiaohua1020"
  },
  
  {
    "title": "音视频及其数字化表示",
    "url": "/posts/av_into/",
    "categories": "技术, 音视频",
    "tags": "P2P, 音视频",
    "date": "2022-03-14 00:00:00 +0800",
    





    
    "snippet": "声音和图像是两种不同的感知形式，它们的本质基于物理学的原理和感知机制。声音和图像的本质声音是由物体振动产生的机械波。当物体振动时，周围的空气分子也会振动，形成压缩和膨胀的波动。这种机械波通过空气传播，被耳朵中的鼓膜接收，然后通过听觉系统转化为我们能够感知的声音。声音的特征由两个主要参数决定：频率和振幅。频率决定了声音的音调，而振幅则决定了声音的音量。图像是通过光传递的信息。光是一种电磁波，当...",
    "content": "声音和图像是两种不同的感知形式，它们的本质基于物理学的原理和感知机制。声音和图像的本质声音是由物体振动产生的机械波。当物体振动时，周围的空气分子也会振动，形成压缩和膨胀的波动。这种机械波通过空气传播，被耳朵中的鼓膜接收，然后通过听觉系统转化为我们能够感知的声音。声音的特征由两个主要参数决定：频率和振幅。频率决定了声音的音调，而振幅则决定了声音的音量。图像是通过光传递的信息。光是一种电磁波，当它照射到物体表面并反射进入眼睛或摄像机时，我们就能够感知到图像。图像的特征由颜色和亮度决定。颜色是由光的频率决定的，而亮度是光的强度。在图像中，颜色和亮度分布形成了我们看到的场景。通过对声音和图像进行数字化处理，可以将连续的模拟信号转换为离散的数字形式，以便更容易地存储、传输、处理和分析。数字化的声音和图像，称为音频和视频，合称音视频。音视频的原始数据是通过摄像机来采集的，音频通过麦克风收集，视频通过 CMOS 采集，数字化之后存储到磁盘里。音频的数字化      采样。连续的模拟音频信号被以固定的时间间隔进行采样，得到一系列离散的采样值。采样的频率决定了每秒采样的次数，通常以赫兹（Hz）为单位。音频的常见采样率是 44.1kHz        量化，即用数字来表示音频幅度。量化深度，也称为采样精度，是模拟信号转换为二进制数字信号的位数。量化深度越高，采样的数字信号精度越高。比如，量化深度为 16 bit，采样的数字信号幅度就有 2^16 = 65536 个档位。音频量化深度一般有 8 bit、16 bit、20bit、24bit 和 32bit 等。        编码，即将量化后的数字转为二进制。常见的编码格式有 AAC，mp3，G711, opus。其中，opus 免费开源，且编码效果好，底噪低，逐渐为流媒体所采用。  上图中，横坐标代表时间，1 秒钟内竖线的条数对应采样率，竖线的高度对应信号幅度，信号幅度的最小单位的倒数则是量化深度。音频数字化的三要素            采样频率（sample rate）      量化位数（bit depth）      声道数（Number of Channels）                  每秒种抽取声音幅度样本的次数      每个采样点用多少二进制位表示数据范围      声音通道的个数              采样率越高，声音质量越高，数据量越大      量化位数越多，音质越好，数据量越大      立体声比单声道表现力更丰富，但数据量翻倍              常用的采样率： * 8,000 Hz - 电话所用采样率  * 11,025 Hz - AM调幅广播所用采样率  * 22,050 Hz - 无线电广播所用采样率  * 32,000 Hz - miniDV 所用采样率  * 44,100 Hz - 音频 CD 所用采样率      * 8 bit，将幅度划分为 2^8 个等级  * 16 bit，共 65536 个量级，达到CD标准  * 32 bit，共 4294967296 个量级      * 单声道并非意味着只有一个喇叭发声，通常会处理成两个喇叭输出同一个声道的声音  * 立体声两个喇叭都发声（通常左右声道有分工），更能感受到空间效果。 * 除了单双声道外，还有其他的更多声道，例如 5.1 、7.1 等等      视频的数字化      采样（Sampling）: 视频信号是由连续的模拟图像构成的。在采样阶段，图像被以固定间隔的方式采样，将连续图像转换为离散像素点。1 秒中内采样的个数对应视频的帧率        量化（Quantization）: 对于每个像素，图像的亮度和颜色被量化为数字值。这通常分为亮度量化和色度量化        色彩空间转换（Optional）: 在某些情况下，视频信号可能需要在不同的色彩空间之间转换，例如从 RGB（Red, Green, Blue） 到 YUV（Luma, Chroma）。这通常是为了更有效地表示和传输图像信息。因为 RGB 色彩空间包含了很多人眼无法分辨的色值，且人眼对亮度（明亮度）的敏感性要远远高于对颜色（色度）的敏感性。Y（Luma）表示亮度，U 和 V（Chroma）表示颜色。通过将颜色信息分离到 U 和 V 分量，可以更有效地压缩颜色信息，使其更适合存储和传输        编码（Encoding）: 最后，编码阶段将量化后的数字值和可能的色彩空间信息以数字信号的形式编码，例如通过使用视频编解码器。常见的编码格式包括 AVC(H.264),HEVC(H.265),VP9,AV1  上图是 H.264 编码的示意图，每幅图像被分割成 8*8 像素尺寸来编码。色彩空间色彩空间（Color space）是对色彩的组织方式。色彩模型（Color model）是一种抽象数学模型，通过一组数字来描述颜色（例如RGB使用三元组、CMYK使用四元组）。由于“色彩空间”有着固定的色彩模型和映射函数组合，非正式场合下，这一词汇也被用来指代色彩模型。常见的色彩模型包括 RGB，YUV(YCbCr)，HSV，HSL，CMYK 等。下面我们重点介绍 YUV 色彩模型。YUV 是一种表示颜色的模型。但是我们常说的 YUV ，其实指的是 YCbCr，其中Y是指亮度分量，Cb指蓝色色度分量，而Cr指红色色度分量，是标准 YUV 的一个翻版，此文中，我们就用 YUV 指代 YCbCr 了。YUV 格式按照数据大小分为三个格式，YUV 420，YUV 422，YUV 444。由于人眼对 Y 的敏感度远超于对 U 和 V 的敏感，所以有时候可以多个 Y 分量共用一组 UV，这样既可以极大得节省空间，又可以不太损失质量。  YUV 420，由 4 个 Y 分量共用一套 UV 分量  YUV 422，由 2 个 Y 分量共用一套 UV 分量  YUV 444，不共用，一个 Y 分量使用一套 UV 分量在这三种类型之下，我们又可以按照 YUV 的排列储存顺序，将其细分为好多种格式。按照 YUV 的排列方式，再次将 YUV 分成三个大类，Planar，Semi-Planar 和 Packed。  Planar YUV 三个分量分开存放  Semi-Planar Y 分量单独存放，UV 分量交错存放  Packed YUV 三个分量全部交错存放封装格式（Byte Stream Format）H.264 编码有两种 Byte Stream Format，分别是 AnnexB 和 AVCC。AnnexB format:([start code] NALU) | ( [start code] NALU) |AVCC format:([extradata]) | ([length] NALU) | ([length] NALU) |In annexb, [start code] may be 0x000001 or 0x00000001.In avcc, the bytes of [length] depends on NALULengthSizeMinusOne in avcc extradata, the value of [length] depends on the size of following NALU and in both annexb and avcc format, the NALUs are no different.  Annex B 多用于网络流媒体中：rtmp、rtp 格式，AVCC 多用于文件存储中mp4的格式H.265 编码和 H.264 不同，其 Byte Stream Format 包含 H.265 Annex B 和 H.265 Parameter Sets使用 FFmpeg 查看视频文件信息我们可以使用 ffmpeg 提供的 ffprobe 工具来查看视频文件信息。从下图中高亮部分可以看到，该视频文件为 mp4 文件，时长 7.62 秒，码率为 13805 kb/s，包含了 2 条 Stream。其中， Video 使用 H.264 编码，色彩空间为 yuv420，分辨率为 1080P(1920*1080)，帧率为 29.97，Audio 使用 aac 编码，采样率为 44.1kHz，立体声  1080p是一种视频分辨率标准，指的是视频的垂直分辨率为1080像素。具体来说，1080p视频的分辨率为1920x1080，其中1920是水平像素数，1080是垂直像素数。字母“p”代表“逐行扫描”（progressive scan）的意思。这意味着视频的每一帧都是通过扫描整个图像的每一行像素来创建的，而不是通过交替扫描奇数和偶数行像素来创建的。与交替扫描的“隔行扫描”（interlaced scan）相比，逐行扫描可以提供更清晰的图像，因为它可以更好地保留运动图像中的细节和清晰度。问题思考：  高亮部分上面的一大串信息是什么？  什么是 yuv420 色彩空间？  为什么帧率不是整数？留给后面的博客解答。^_^参考资料  https://www.volcengine.com/docs/6489/72015  https://zh.wikipedia.org/zh-cn/%E8%89%B2%E5%BD%A9%E7%A9%BA%E9%96%93  https://zhuanlan.zhihu.com/p/384455058  ChatGPT"
  },
  
  {
    "title": "P2P 技术及其应用",
    "url": "/posts/p2p_intro/",
    "categories": "技术, 计算机网络",
    "tags": "P2P, 计算机网络",
    "date": "2022-03-14 00:00:00 +0800",
    





    
    "snippet": "我们知道，常规的视频直播通常是通过 rtsp 或者 hls 协议直播的，这种直播的特点是所有的流量都需要从中心服务器发出，经过 CDN(Content Delivery Network)，下发到各个终端。这种直播适合大量人群观看，但是服务器的带宽成本也很高。为了节约成本，基于 P2P 技术的音视频直播应运而生，且已广泛应用于在线聊天(webRTC)，网络摄像机等领域。那么什么是 P2P 技术...",
    "content": "我们知道，常规的视频直播通常是通过 rtsp 或者 hls 协议直播的，这种直播的特点是所有的流量都需要从中心服务器发出，经过 CDN(Content Delivery Network)，下发到各个终端。这种直播适合大量人群观看，但是服务器的带宽成本也很高。为了节约成本，基于 P2P 技术的音视频直播应运而生，且已广泛应用于在线聊天(webRTC)，网络摄像机等领域。那么什么是 P2P 技术呢？这种技术又如何应用于视频直播呢？P2P 技术对等式网络（peer-to-peer， 简称 P2P），又称点对点技术，是无中心服务器、依靠用户群（peers）交换信息的互联网体系，它的作用在于，减低以往网路传输中的节点，以降低资料遗失的风险。与有中心服务器的中央网络系统不同，对等网络的每个用户端既是一个节点，也有服务器的功能，任何一个节点无法直接找到其他节点，必须依靠其户群进行信息交流。听上去和 Git 有着异曲同工之妙。所以，只要知道了对方的 IP 地址，就能直接连接了吗？在没有配置 NPTv6(Network Prefix Translation for IPv6) 的 IPv6 网络下，如果知道了对方的 IPv6 地址，是可以直接连接的，IPv6 地址通常是全球唯一的，因此每个设备可以直接在 Internet 上具有全局可达的 IPv6 地址。但是，在 IPv4 网络环境下，无法直接连接，因为存在 NAT(Network Address Translation)。NAT 及分类NAT 技术是为了解决 IPv4 地址短缺问题而提出的。IPv4 地址是 32 位二进制数，可以表示的地址数量是 2 的 32 次方，也就是 4294967296 个。然而，其中一部分地址被保留用于特殊用途，比如私有地址、广播地址、多播地址等，因此实际可用的IPv4地址数量要比这个数字少一些。此外，IPv4 地址的分配也不是均匀的，有些地区和组织分配到的地址比其他地区和组织多，这也导致了 IPv4 地址的短缺问题。NAT 技术通过将内部网络的私有 IP 地址转换为公共 IP 地址，使得多个内部主机可以共享一个公共 IP 地址访问互联网，从而解决了 IPv4 地址短缺的问题。此外，NAT 技术还可以提高网络安全性，因为它可以隐藏内部网络的 IP 地址，使得外部网络无法直接访问内部网络。NAT 有三种类型:  静态 NAT，静态一对一的地址转换。需要手动配置映射关系，若网路拓扑改变，则需更新配置，管理与维护难度大。通常用于企业内部网络            内网 IP      外网 IP                  192.168.1.55      219.152.168.222              192.168.1.59      219.152.168.223              192.168.1.155      219.152.168.224            动态 NAT（Pooled NAT），动态地址池转换。内部网络的私有 IP 地址转换时从一个地址池中选取公有 IP 地址，对应关系有租期限制内网 IP 和外网 IP 也是一对一的映射关系，和静态 NAT 的区别就是映射关系会动态改变        NAPT（Network Address Port Translation，端口地址转换）：是一种特殊的动态 NAT，它不仅将内部主机的IP地址映射到一个公共 IP 地址，还将内部主机的端口号映射到公共 IP 地址的不同端口号上，以实现多个内部主机共享一个公共 IP 地址访问外部网络。              内网 IP      外网 IP                  192.168.1.55:5555      219.152.168.222:9200              192.168.1.59:80      219.152.168.223:9201              192.168.1.155:4456      219.152.168.224:9202      家用路由器一般使用 NAPT，拥有复杂网络的大型公司内网则会使用 Static NAT 和 Dynamic NAT，本文讨论的 NAT 是第三种 NAT。锥型和对称型 NAT第三种 NAPT 又可以分为锥型和对称型 NAT (Symmetric NAT)。锥型 NAT 又可以细分为 Full Cone NAT, Address Restricted Cone NAT, Port Restricted Cone NAT，每一种 NAT 对于外部请求的响应方式有所不同。  Full Cone NAT，完全锥型一旦内部地址（iAddr:iPort）映射到外部地址（eAddr:ePort），所有发自 iAddr:iPort 的数据包都经由 eAddr:ePort 向外发送。任意外部主机都可以通过发送数据包给 eAddr:ePort 给 NAT设备内部的 iAddr:iPort 主机。  Address Restricted Cone NAT，地址受限型在完全锥型 NAT 的基础上限制了 IP 地址。只有和内部地址有过通信的外部地址，才能发送消息  Port Restricted Cone NAT，端口受限型在地址受限型 NAT 的基础上限制了端口，特定外部地址的特定端口，才能发送消息  Symmetric NAT，对称型可以用如下代码在 Chrome 浏览器里检测当前网络的 NAPT 的类型：// parseCandidate from https://github.com/fippo/sdpfunction parseCandidate(line) {  var parts;  // Parse both variants.  if (line.indexOf('a=candidate:') === 0) {    parts = line.substring(12).split(' ');  } else {    parts = line.substring(10).split(' ');  }  var candidate = {    foundation: parts[0],    component: parts[1],    protocol: parts[2].toLowerCase(),    priority: parseInt(parts[3], 10),    ip: parts[4],    port: parseInt(parts[5], 10),    // skip parts[6] == 'typ'    type: parts[7]  };  for (var i = 8; i &lt; parts.length; i += 2) {    switch (parts[i]) {      case 'raddr':        candidate.relatedAddress = parts[i + 1];        break;      case 'rport':        candidate.relatedPort = parseInt(parts[i + 1], 10);        break;      case 'tcptype':        candidate.tcpType = parts[i + 1];        break;      default: // Unknown extensions are silently ignored.        break;    }  }  return candidate;};var candidates = {};var pc = new RTCPeerConnection({iceServers: [    {urls: 'stun:stun1.l.google.com:19302'},    {urls: 'stun:stun2.l.google.com:19302'}]});pc.createDataChannel(\"foo\");pc.onicecandidate = function(e) {  if (e.candidate &amp;&amp; e.candidate.candidate.indexOf('srflx') !== -1) {    var cand = parseCandidate(e.candidate.candidate);    if (!candidates[cand.relatedPort]) candidates[cand.relatedPort] = [];    candidates[cand.relatedPort].push(cand.port);  } else if (!e.candidate) {    if (Object.keys(candidates).length === 1) {      var ports = candidates[Object.keys(candidates)[0]];      console.log(ports.length === 1 ? 'normal nat' : 'symmetric nat');    }  }};pc.createOffer().then(offer =&gt; pc.setLocalDescription(offer))IP 数据包通过 NAT 设备（如路由器）时，NAT 会重写来源 IP 地址和目的地 IP 地址，从而实现同一内网中不同主机共用公网 IP 地址的功能。NAT示意图如上图所示，192.168.100.3 的主机向 209.131.36.158 的 80 端口发送 HTTP 请求，经过 NAT 时，NAT 根据其保存的映射表，找到该主机对应的外网 IP 地址和端口，即 145.12.131.7:6282，然后替换 IP 数据包的 Source 字段为该地址，并发送给 www.yahoo.com。雅虎服务器发送 response 的时候，Dest 即为 145.12.131.7:6282，然后 NAT 转发给 192.168.100.3 的 3855 端口。但是，如果某个外网主机想主动访问 192.168.100.3，显然不能到达内网的 192.168.100.3 主机，即使该主机知道了我们的公网 IP，它在主动建立连接时，NAT 发现并没有该地址和局域网内地址的映射，该数据包就会被 NAT 设备丢弃。  NAT 转换表的生成与 TCP/IP 报文的 IP 地址、端口号转换操作会产生一定的开销。NAT 技术使用非常广泛，但也存在一些缺点:  NAT 设备需要对收发的数据包重新编辑修改（IP 地址转换，重新计算校验），此操作会降低网络数据的传输速度  NAT 设备端口老化问题，会导致连接中的设备异常断开，因为 NAT 设备需要维护端口映射表，而硬件资源有限，所以有些 NAT 设备会定时断开部分连接  部分网络协议无法通过 NAT 设备，让两台设备直接连接变得困难，因此，才出现了 NAT 打洞技术NAT 打洞NAT 打洞是一种技术，用于在两个位于不同私有网络中的设备之间建立直接通信。NAT 打洞通常使用 UDP 协议，所以也称为 UDP 打洞。下面是 UDP 打洞的基本流程：  设备 A 和设备 B 都位于不同的私有网络中，它们都无法直接通信。  设备 A 向设备 B 发送一个 UDP 数据包，这个数据包包含了设备 A 的 IP 地址和端口号。  设备 B 收到这个数据包后，会记录下设备 A 的 IP 地址和端口号，并向设备A发送一个 UDP 数据包，这个数据包包含了设备 B 的 IP 地址和端口号。  设备 A 收到这个数据包后，会记录下设备 B 的 IP 地址和端口号。  现在，设备 A 和设备 B 都知道了对方的 IP 地址和端口号，它们可以直接通过这些信息进行 UDP 通信了。                            Server S                        18.181.0.31:5678                               |                               |        +----------------------+----------------------+        |                                             |      NAT A                                         NAT B155.99.25.11:62000                            138.76.29.7:31000        |                                             |        |                                             |     Client A                                      Client B192.168.0.100:1234                              10.1.1.3:1234那么问题来了，设备 A 向设备 B 发送一个 UDP 数据包，那么设备 A 如何知道设备 B 的 IP 地址和端口号呢？这就需要中介服务器了。这个中介服务器可以是一个公网服务器或者是一个 STUN 服务器。  TCP 可以打洞吗？UDP 打洞和 TCP 打洞的本质是一样的，都是通过在 NAT 设备上创建映射来实现两个位于不同 NAT 后面的主机之间的直接通信。但是，由于 UDP 协议的特点，UDP 打洞更加简单和高效。STUNSTUN（Session Traversal Utilities for NAT）是一种用于穿越网络地址转换（NAT）的协议，它通常用于 P2P 通信中的打洞操作。P2P 打洞旨在允许两个设备在 NAT 后进行直接通信，而不需要通过中间服务器。Google 提供的 STUN 服务器，可以使用 webRTC 的 demo 测试下。NAT 有不同的类型，不是所有 NAT 都支持 NAT 打洞，如前面提到的 Symmetric NAT 则无法打洞。UDP 打洞的成功率约为 60%，当打洞失败时，则使用基于 TURN 服务器的中继模式。TURNTraversal Using Relays around NAT (TURN)旨在通过打开与 TURN 服务器的连接并通过该服务器中继所有信息来绕过对称 NAT 限制。您将创建与 TURN 服务器的连接，并告诉所有对等方将数据包发送到服务器，然后将其转发给您。这显然会带来一些开销，因此只有在没有其他选择的情况下才使用它。经过 TURN 服务器中转的模式，通常称为 relay。参考资料  https://en.wikipedia.org/wiki/Network_address_translation  https://developer.mozilla.org/en-US/docs/Web/API/WebRTC_API/Protocols  https://juejin.cn/post/6844904098572009485  https://webrtchacks.com/symmetric-nat/  https://www.volcengine.com/docs/6489/72015"
  },
  
  {
    "title": "子集生成",
    "url": "/posts/subset_generate/",
    "categories": "技术, 数据结构与算法",
    "tags": "leetcode, 算法, 暴力求解",
    "date": "2019-08-30 00:00:00 +0800",
    





    
    "snippet": "很多问题都可以“暴力解决”。不需要动太多脑筋，把所有的可能性都列出来，然后一一实验。这样的方法显得很“笨”，却往往是行之有效的。 并且，很多问题拆分后的子问题，也需要用暴力求解的思想，比如 BFS 搜索最短路径，就需要列出所有可能，然后加入队列。本篇讨论暴力求解的其中一个问题，子集生成问题。其他暴力求解的问题，如简单枚举，枚举排列，回溯法，路径寻找（隐式图的遍历）等问题，本篇暂不讨论。子集生...",
    "content": "很多问题都可以“暴力解决”。不需要动太多脑筋，把所有的可能性都列出来，然后一一实验。这样的方法显得很“笨”，却往往是行之有效的。 并且，很多问题拆分后的子问题，也需要用暴力求解的思想，比如 BFS 搜索最短路径，就需要列出所有可能，然后加入队列。本篇讨论暴力求解的其中一个问题，子集生成问题。其他暴力求解的问题，如简单枚举，枚举排列，回溯法，路径寻找（隐式图的遍历）等问题，本篇暂不讨论。子集生成问题给定一个集合，枚举出所有可能的子集。leetcode 第 78 题所有的自己生成问题都可以用三种方法来解决。增量构造法，位向量法，和二进制法。增量构造法思路是每次选出一个元素放入集合中。比如对于题目中给的例子 [1,2,3] 来说，最开始是空集，那么我们现在要处理 1，就在空集上加 1，为 [1]，现在我们有两个自己 [] 和 [1]，下面我们来处理 2，我们在之前的子集基础上，每个都加个 2，可以分别得到 [2]，[1, 2]，那么现在所有的子集合为 [], [1], [2], [1, 2]，同理处理 3 的情况可得 [3], [1, 3], [2, 3], [1, 2, 3], 再加上之前的子集就是所有的子集合了，代码如下：vector&lt;vector&lt;int&gt;&gt; subsets(vector&lt;int&gt; &amp;S) {    vector&lt;vector&lt;int&gt;&gt; res(1);    sort(S.begin(), S.end());    for (int i = 0; i &lt; S.size(); i++) {        int size = res.size();        for (int j = 0; j &lt; size; j++) {            res.push_back(res[j]);            res.back().push_back(S[i]);        }    }    return res;}整个添加的顺序为：[][1][2][1 2][3][1 3][2 3][1 2 3]位向量法由于原集合每一个数字只有两种状态，要么存在，要么不存在，那么在构造子集时就有选择和不选择两种情况，所以可以构造一棵二叉树，左子树表示选择该层处理的节点，右子树表示不选择，最终的叶节点就是所有子集合，树的结构如下:                        []                           /          \\                          /            \\                      /              \\              [1]                []           /       \\           /    \\          /         \\         /      \\               [1 2]       [1]       [2]     []      /     \\     /   \\     /   \\    / \\  [1 2 3] [1 2] [1 3] [1] [2 3] [2] [3] []    代码如下：vector&lt;vector&lt;int&gt;&gt; subsets(vector&lt;int&gt; &amp;S) {    vector&lt;vector&lt;int&gt;&gt; res;    vector&lt;int&gt; path;    sort(S.begin(), S.end());    genSubsets(S, 0, path, res);    return res;}void genSubsets(vector&lt;int&gt; &amp;S, int pos, vector&lt;int&gt; &amp;path, vector&lt;vector&lt;int&gt;&gt; &amp;res) {    res.push_back(path);    for (int i = pos; i &lt; S.size(); i++) {        path.push_back(S[i]);        genSubsets(S, i + 1, path, res);        path.pop_back();    }}整个添加的顺序为:[][1][1 2][1 2 3][1 3][2][2 3][3]二进制法由于集合中每个元素只有两种可能，选 与 不选。正好对应二进制的 1 和 0。于是，很自然的想到用二进制数字来表示集合的选择情况。下面是二进制数字和对应的集合。                   1      2      3      Subset                  0      0      0      0      []              1      0      0      1      [3]              2      0      1      0      [2]              3      0      1      1      [2,3]              4      1      0      0      [1]              5      1      0      1      [1,3]              6      1      1      0      [1,2]              7      1      1      1      [1,2,3]      对应的代码如下：vector&lt;vector&lt;int&gt;&gt; subsets(vector&lt;int&gt; &amp;S) {    vector&lt;vector&lt;int&gt;&gt; res;    sort(S.being(), S.end());    int max = 1 &lt;&lt; S.size();    for (int k = 0; k &lt; max; k++) {        vector&lt;int&gt; out = genSubset(S, k);        res.push_back(out);    }    return res;}vector&lt;int&gt; genSubset(vector&lt;int&gt; &amp;S, int k) {    vector&lt;int&gt; sub;    int idx = 0;    for (int i = k; i &gt; 0; i = i &gt;&gt; 1) {        if ((i &amp; 1) == 1) {            sub.push_back(S[idx]);        }        idx++;    }    return sub;}"
  },
  
  {
    "title": "二分搜索及其应用",
    "url": "/posts/binary_search/",
    "categories": "技术, 数据结构与算法",
    "tags": "leetcode, 数据结构与算法, 二分搜索",
    "date": "2019-08-23 00:00:00 +0800",
    





    
    "snippet": "二分搜索简介在计算机科学中，二分搜索（binary search）也称折半搜索（half-interval search）、对数搜索（logarithmic search），是在有序数组中查找某一特定元素的搜索算法。其基本思想是通过逐次比较数组特定范围的中间元素与目标元素的大小，每次缩小一半的搜索范围，来提高搜索效率。二分搜索的时间复杂度是 O(log n)，空间复杂度为 O(1)。这里是 ...",
    "content": "二分搜索简介在计算机科学中，二分搜索（binary search）也称折半搜索（half-interval search）、对数搜索（logarithmic search），是在有序数组中查找某一特定元素的搜索算法。其基本思想是通过逐次比较数组特定范围的中间元素与目标元素的大小，每次缩小一半的搜索范围，来提高搜索效率。二分搜索的时间复杂度是 O(log n)，空间复杂度为 O(1)。这里是 leetcode 中和二分搜索有关的习题。leetcode 上有个二分查找的专题练习卡片例题一最简单情形的二分搜索。注意循环的判定条件，和 start end 赋值更新逻辑。leetcode 第 704 题int search(vector&lt;int&gt;&amp; nums, int target) {    int res = -1;    int start = 0, end = nums.size() - 1;    int mid = 0;    while (start &lt;= end) {        mid = start + (end - start) / 2;        if (nums[mid] &lt; target) {            start = mid + 1;        }else if (nums[mid] &gt; target) {            end = mid - 1;        }else {            res = mid;            break;        }    }    return res;}变形如果数组中有重复数字，找到该数字的起始和终止位置。 leetcode 第 34 题// 起始位置int lower_bound(vector&lt;int&gt;&amp; nums, int target) {    int res = -1;    int start = 0, end = nums.size() - 1;    int mid = 0;    while (start &lt;= end) {        mid = start + (end - start) / 2;        if (nums[mid] &lt; target) {            start = mid + 1;        }else if (nums[mid] &gt; target) {            end = mid - 1;        }else {            res = mid;            end = mid - 1;        }    }    return res;}// 终止位置int upper_bound(vector&lt;int&gt;&amp; nums, int target) {    int res = -1;    int start = 0, end = nums.size() - 1;    int mid = 0;    while (start &lt;= end) {        mid = start + (end - start) / 2;        if (nums[mid] &lt; target) {            start = mid + 1;        }else if (nums[mid] &gt; target) {            end = mid - 1;        }else {            res = mid;            start = mid + 1;        }    }    return res;}旋转数组问题旋转数组：顾名思义，一个有序的数组，从某个位置分成两部分，然后把这两部分颠倒顺序后形成的新数组。(i.e., [0,1,2,4,5,6,7] might become [4,5,6,7,0,1,2]).旋转数组的搜索假设没有重复元素，使用二分搜索，难点在于左右边界的限定。注意小于等于号的位置。leetcode 第 33 题int search(vector&lt;int&gt;&amp; nums. int target) {    int res = -1;    int start = 0, end = nums.size() - 1;    int mid = 0;    while (start &lt;= end) {        mid = start + (end - start) / 2;        if (nums[mid] == target) {            res = mid;            break;        }        if (nums[start] &lt;= nums[mid]) {            if (nums[start] &lt;= target &amp;&amp; target &lt; nums[mid]) {                end = mid - 1;            }else {                start = mid + 1;            }        }else {            if (nums[mid] &lt; target &amp;&amp; target &lt;= nums[end]) {                start = mid + 1;            }else {                end = mid - 1;            }        }    }    return res;}如果有重复元素的话，该如何修改呢？leetcode 第 81 题上一题如果 nums[start] &lt;= nums[mid], 那么 [start, mid] 为递增序列的假设不成立，比如 [1, 3, 1, 1, 1]。如果 nums[start] &lt;= nums[mid] 不能确定递增，那么就把它拆分为两个条件：  如果 nums[start] &lt; nums[mid]，那么区间 [start, mid] 必然递增  如果 nums[start] == nums[mid]，那么 start++，往下看一步即可    int search(vector&lt;int&gt;&amp; nums. int target) { int res = -1; int start = 0, end = nums.size() - 1; int mid = 0; while (start &lt;= end) {     mid = start + (end - start) / 2;     if (nums[mid] == target) {         res = mid;         break;     }     if (nums[start] &lt; nums[mid]) {         if (nums[start] &lt;= target &amp;&amp; target &lt; nums[mid]) {             end = mid - 1;         }else {             start = mid + 1;         }     }else if (nums[start] &gt; nums[mid]) {         if (nums[mid] &lt; target &amp;&amp; target &lt;= nums[end]) {             start = mid + 1;         }else {             end = mid - 1;         }     }else {         start++;     } } return res;}        假设没有重复元素，搜索最小值、最大值。leetcode 第 153 题以下是搜索最小值的算法，搜索最大值同理，只需要改下返回值和 start, end 的赋值逻辑。    int findMin(vector&lt;int&gt;&amp; nums) { if (nums.size() == 0) return -1; if (nums.size() == 1) return nums[0]; int start = 0, end = nums.size() - 1;  while (start &lt; end) {     if (nums[start] &lt; nums[end]) {         return nums[start];     }     int mid = start + (end - start) / 2;     if (nums[start] &lt;= nums[mid]) {         start = mid + 1;     }else {         end = mid;     } } return nums[start];        }            如果有相同元素该怎么办呢？和查找元素类似，在相等的时候做特殊处理。leetcode 第 154 题    int findMin(vector&lt;int&gt;&amp; nums) { if (nums.size() == 0) return -1; if (nums.size() == 1) return nums[0]; int start = 0, end = nums.size() - 1;  while (start &lt; end) {     if (nums[start] &lt; nums[end]) {         return nums[start];     }     int mid = start + (end - start) / 2;     if (nums[start] &lt; nums[mid]) {         start = mid + 1;     }else if (nums[start] &gt; nums[mid]){         end = mid;     }else {         start++;     } } return nums[start];            }              多个数组查找查找两个有序数组的中位数。leetcode 第 4 题这道题很难，不仅思路很难理清楚，corner case 也需要考虑。 当然，可以选择把两个数组合并成一个，然后使用二分查找。时间复杂度是 O(m + n), 空间复杂度是 O(m + n)，但这显然不是最优解。解法见这里二维数组搜索上面的题目都是一维的数组，那么如何在二维数组中使用二分搜索呢？leetcode 第 74 题可以用两次二分搜索，先找到行数，再找到列数。也可以直接用一次二分搜索，但是需要把二维坐标和一维坐标做转换。bool searchMatrix(vector&lt;vector&lt;int&gt;&gt;&amp; matrix, int target) {    if (matrix.empty() || matrix[0].empty()) return false;    if (target &lt; matrix[0][0] || matrix.back().back() &lt; target) return false;    int left = 0, right = matrix.size() - 1;    int mid = 0;    while (left &lt;= right) {        mid = left + (right - left) / 2;        if (matrix[mid][0] &lt; target) {            left = mid + 1;        }else if (matrix[mid][0] &gt; target) {            right = mid - 1;        }else {            return true;        }    }    int row = right;    left = 0, right = matrix[row].size() - 1;    while (left &lt;= right) {        mid = left + (right - left) / 2;        if (matrix[row][mid] &lt; target) {            left = mid + 1;        }else if (matrix[row][mid] &gt; target) {            right = mid - 1;        }else {            return true;        }    }    return false;}一次二分搜索。一维数组中的 i 对应二维数组中的行号是 i / n, 列号是 i % n。bool searchMatrix(vector&lt;vector&lt;int&gt;&gt;&amp; matrix, int target) {    if (matrix.empty() || matrix[0].empty()) return false;    if (target &lt; matrix[0][0] || matrix.back().back() &lt; target) return false;    int m = matrix.size(), n = matrix[0].size();    int left = 0, right = m * n - 1;    int mid = 0;    while (left &lt;= right) {        mid = left + (right - left) / 2;        int num = matrix[mid / n][mid % n];        if (num == target) {            return true;        }else if (num &lt; target) {            left = mid + 1;        }else {            right = mid - 1;        }    }    return false;}树的搜索最常见的就是 BST 了。BST 按照中序遍历即是一个有序数组。leetcode 第 230 题由于遍历二叉树有递归和迭代两种方法，所以这道题也有对应的两种解法。int kthSmallest(TreeNode* root, int k) {    int count = countNodes(root-&gt;left);    if (k &lt;= count) {        return kthSmallest(root-&gt;left, k);    }else if (k &gt; count + 1) {        return kthSmallest(root-&gt;left, k - count - 1);    }    return root-&gt;val;}int countNodes(TreeNode *node) {    if (!node) return 0;    return 1 + countNodes(node-&gt;left) + countNodes(node-&gt;right);}int kthSmallest(TreeNode* root, int k) {    int res = -1;    stack&lt;TreeNode *&gt; s;    TreeNode *p = root;    int cnt = 0;    while (!s.empty() || p) {        while (p) {            s.push(p);            p = p-&gt;left;        }        p = s.top();        s.pop();        cnt++;        if (cnt == k) {            res = p-&gt;val;            break;        }        p = p-&gt;right;    }    return res;}完全二叉树插入新节点问题。（ Google 校招面试题 ）leetcode 第 919 题给出一个完全二叉树，要求插入一个新节点后仍然为完全二叉树。可以用 BFS, 当遇到第一个没有左儿子或右儿子的节点时，插入到对应的位置。时间复杂度 O(n)，空间复杂度 O(n)。void insert(TreeNode *root, TreeNode *newNode) {    if (!root) return;    queue&lt;TreeNode *&gt; q;    q.push(root);    while (!q.empty()) {        TreeNode *node = q.top();        q.pop();        if (!node-&gt;left) {            node-&gt;left = newNode;            break;        }        if (!node-&gt;right) {            node-&gt;right = newNode;            break;        }        if (node-&gt;left) {            q.push(node-&gt;left);        }        if (node-&gt;right) {            q.push(node-&gt;right);        }    }}也可以用二分搜索，每次判断当前节点的左右儿子的最大深度，记为 dl, dr, 如果 dl &gt; dr, 则向左子树再次执行该操作，否则向右子树再次执行该操作。直到找到没有左儿子或者右儿子的节点。int depth(TreeNode *node) {    int d = 0;    while (node) {        d++;        node = node-&gt;right;    }    return d;}void insert(TreeNode *root, TreeNode *node) {    TreeNode *root = this-&gt;root;    int dl = depth(root-&gt;left), dr = depth(root-&gt;right);    TreeNode *node = new TreeNode(v);    while (root) {        if (!root-&gt;left) {            root-&gt;left = node;            break;        }        if (!root-&gt;right) {            root-&gt;right = node;            break;        }        if (dl == dr) {            root = root-&gt;left;            dr = dl - 1;            dl = depth(root-&gt;left);        }else {            root = root-&gt;right;            dl = depth(root-&gt;left);            dr = dr - 1;        }    }}还有另一种思路，可以借助当前树的总节点个数来实现 O(log n) 复杂度的插入。详情见这里其他数学问题如求解 Sqrt(x)。leetcode 第 69 题int mySqrt(int x) {    if (x &lt; 2) return x;    int start = 0, end = x, mid = 0;    int res = 1;    while (start &lt;= end) {        mid = start + (end - start) / 2;        if (x / mid == mid) {            res = mid;            break;        }else if (x / mid &lt; mid) {            end = mid - 1;        }else {            start = mid + 1;            res = mid;        }    }    return res;}下面来看一道 Google 面试题。分蛋糕问题大致意思是，n 个人平分 m 个蛋糕，问每个人分得的最大面积是多少（一个蛋糕可以分给多个人，多个蛋糕不能分给同一个人）二分法求满足人数的最大面积。bool possible(vector&lt;int&gt; &amp;areas, int x, int n) {    bool res = false;    int k = 0;    for (auto a : areas) {        k += a / x;        if (k &gt;= n) {            res = true;            break;        }    }    return res;}int maximumAreaServingCake(vector&lt;int&gt; radii, int n) {    vector&lt;int&gt; areas(radii.size());    int maxArea = 0;    for (int i = 0; i &lt; radii.size(); i++) {        int r = radii[i];        areas[i] = M_PI * r * r;        maxArea = max(maxArea, areas[i]);    }    int l = 0, r = maxArea;    int x = 0;    while (r - l &lt;= 1e-5) {        x = l + (r - l) / 2;        if (possible(x)) {            l = x;        }else {            r = x;        }    }    return round(x * 10000) / 10000;}可以看到，二分搜索的应用领域很广，应用场景也很多样。在不同的数据结构中，二分搜索都有用武之地。"
  },
  
  {
    "title": "iOS 中的 Crash 探究",
    "url": "/posts/ios_crash_intro/",
    "categories": "技术, iOS",
    "tags": "Crash, iOS, 异常处理",
    "date": "2018-11-28 00:00:00 +0800",
    





    
    "snippet": "Crash 是我们在日常使用 App 时，偶尔会遇到的“闪退”。闪退会带来糟糕的用户体验，影响 App 的正常使用。 App 的 Crash 率是衡量该App质量的标准之一。美团 App 的 Crash 率一般控制在万分之五以下。 下面，我主要谈谈 iOS 中 App 的 Crash，并结合实际开发工作，给出一些排查建议。Crash是什么？Crash 本质是一种异常控制。现代操作系统需要有一...",
    "content": "Crash 是我们在日常使用 App 时，偶尔会遇到的“闪退”。闪退会带来糟糕的用户体验，影响 App 的正常使用。 App 的 Crash 率是衡量该App质量的标准之一。美团 App 的 Crash 率一般控制在万分之五以下。 下面，我主要谈谈 iOS 中 App 的 Crash，并结合实际开发工作，给出一些排查建议。Crash是什么？Crash 本质是一种异常控制。现代操作系统需要有一整套完善的处理流程来解决异常。这种流程叫做 Exception Control Flow（ECF）。异常控制可以发生在硬件层，软件层和应用层。在硬件层，硬件检测到的事件，会触发控制突然转移到异常处理程序。在操作系统层，内核通过上下文转换将控制从一个用户进程转移到另一个用户进程。在应用层，一个进程可以发送信号到另一个进程。如在终端执行 kill 命令，杀死其他进程。一般而言，App 的 Crash 和硬件没有直接关系，所以我们主要来看操作系统和应用层的异常处理。操作系统的异常控制操作系统的异常分为4种。中断（interrupt），陷阱（trap），故障（fault）和终止（abort）。注: 该分类源于《深入理解计算机系统 》第8章，作者 Randal E Bryant, David R. O’Hallaron。有些观点认为中断不属于异常。我的理解是该书中的异常是广义上的异常，是进程没有按照原先的逻辑来执行的所有异常情况，从这个角度来看，它包括了中断。            类别      原因      异步/同步      返回行为                  中断      来自I/O设备的信号      异步      总是返回到下一个指令              陷阱      有意的异常      同步      总是返回到下一个指令              故障      潜在可恢复的错误      同步      可能返回到当前指令              终止      不可恢复的错误      同步      不会返回      中断（interrupt）是唯一一个异步发生的异常。由硬件产生，通过中断控制器发送给 CPU，CPU 判断中断来源后发送到操作系统内核，最后到达用户进程。举个例子。当我们把 iPhone 由竖屏旋转至横屏时，iPhone 中的陀螺仪会产生一系列中断，经过中断处理程序和操作系统内核的处理，最终使得App接收到横屏的 notification，并作出响应。 陷阱（trap）是有意的异常，主要作用是提供系统调用。如打开文件。故障（fault）是由错误引起。可能会被故障处理程序修复，如缺页异常。终止（abort）是不可恢复的致命错误。通常是由硬件产生。通常情况下，在操作系统层，fault 是导致App Crash的主要因素。比如常见的 SegmentFault 是一种 fault，它是指段错误，访问了错误的内存地址。一般而言不可被故障处理程序修复，会直接导致进程退出。应用层的异常控制不同的应用软件，有不同的异常控制。Java 的 JVM 和 iOS 的 runtime 是两套运行时环境，他们的异常控制机制有所不同。在Java中，所有的异常都有一个共同的祖先 Throwable。Throwable 有两个子类，Error 和 Exception。  Error，是程序无法处理的错误，意味着代码运行时JVM出现了问题。如 Virtual Machine Error，和 Out Of Memory Error。  Exception，是程序本身可以处理的异常。如 Null Pointer Exception、Arithmetic Exception。安卓 App 的大部分 Crash 会在 JVM 这一层检测并得到处理。iOS App 的运行基于 runtime 环境。它也提供了一些异常控制，防止异常传递到操作系统层。如 Unrecognized selector sent to instance 就属于 runtime 的保护措施。Crash的原因App 发生 Crash 的原因可能有很多种。CPU无法执行代码      非法算术运算。除0计算。        无效的指令。如基于 x86_64 架构的 CPU（CISC指令集），无法运行在基于 ARM 架构的 CPU（RISC 指令集）。也可能是其他无效指令，如把数据当成指令的情况。        无效的内存地址。应用程序在内存中的内存布局如下图所示。  由低地址到高地址依次为：  代码段（.text）  已初始化的数据（.data）  未初始化的数据（.bss）  堆（heap）  栈（stack）当进程在执行时，会在栈中创建保存指针的变量 pointer，pointer 指向堆中对象的内存地址。如果堆中对象的内存地址被释放，但是 pointer 未置空，那么随着进程不断执行，后续会向这块堆中的内存写数据，如果继续访问该 pointer，则很可能会导致 Crash。这种 pointer 被称为野指针。通常情况下，多线程操作是导致这种情况出现的主要因素。操作系统出于某种因素      WatchDog 事件。用来检测应用是否长时间无响应，模拟器无此功能。        机器过热可能是由于 CPU 负载太高。操作系统会优先 kill 掉 CPU 占有率过高的 App.        内存不足 App 在运行期间可能会收到 memoryWarning。在这个方法里面应该做一些释放内存的操作。        签名无效比如企业证书到期，App 启动时就会直接退出。  编程语言的保护措施      找不到指定方法。Runtime 提供的保护措施。        数组越界。  不是所有语言都提供这种保护措施。如C语言就不提供数组越界的保护。如下代码，第三行，在 C 语言中是不会 Crash 的，但是第四行打印出来的内容是未知的。 在第七行是 Objective-C 代码，同样是数组越界，它就必然会发生 Crash。int main () {    char str[6] = {'b','i','t','n','p','c'};    char c = str[6];                    // 不会Crash    printf(\"%c\\n\", c);                  // 打印出的字符未知    NSArray *array = @[@\"b\", @\"i\", @\"t\", @\"n\", @\"p\", @\"c\"];    id obj = array[6];                  // Crash    NSLog(@\"%@\\n\", obj);}开发者的防范措施这里主要是指用 Assert 来检查某些重要的参数。Crash传递的流程与捕获方式当 App 发生 Crash 时，是有一定的传递流程的。这里以 iOS App 的 Crash 为例。 在操作系统层其传递顺序为 Mach 内核-&gt;Unix。在应用层，则会产生一个 NSException。所以捕获的时候，就可以分别在对应的层次捕获堆栈信息。 苹果为了统一机制，操作系统和用户操作都会产生 Mach 异常。所以所有 Crash 都有对应 Mach 异常的 exception_type。最后，把捕获到的 CrashLog 符号化，转化为可读的堆栈信息。Mach异常Mach 异常是最底层的内核级异常，如 EXC_BAD_ACCESS。在异常发生时，会被异常处理程序转换为 Mach 消息，接着依次投递到 thread，task 和 host 端口。通过监听这些端口，来捕获 Mach 层的异常。这里以 PLCrashReporter 为例（此处仅列出关键代码）。具体代码可查看 PLCrashMachExceptionServer// Initialize the bare context. // Initalize our server's portmach_port_allocate(mach_task_self(), MACH_PORT_RIGHT_RECEIVE, &amp;_serverContext-&gt;server_port);// Initialize our notification portmach_port_allocate(mach_task_self(), MACH_PORT_RIGHT_RECEIVE, &amp;_serverContext-&gt;notify_port);mach_port_insert_right(mach_task_self(), _serverContext-&gt;notify_port, _serverContext-&gt;notify_port, MACH_MSG_TYPE_MAKE_SEND);// Initialize our port set.mach_port_allocate(mach_task_self(), MACH_PORT_RIGHT_PORT_SET, &amp;_serverContext-&gt;port_set);// Add the service port to the port setmach_port_move_member(mach_task_self(), _serverContext-&gt;server_port, _serverContext-&gt;port_set);// Add the notify port to the port setmach_port_move_member(mach_task_self(), _serverContext-&gt;notify_port, _serverContext-&gt;port_set);// Spawn the server thread.pthread_create(&amp;thr, &amp;attr, &amp;exception_server_thread, _serverContext)Mach 异常即使注册了对应的处理，也不会影响原先的传递流程。Mach 异常会继续传递到 Unix 层，转变为 Unix Signal。但是如果 Mach 异常让进程退出，则对应的 Unix 信号则不会产生。一个 Mach 异常对应一个或多个 Unix Signal。常见的exception_types            Exception类型      描述      说明                  EXC_BAD_ACCESS      Bad Memory Access      错误内存地址，访问的地址不存在或者当前进程没有权限都会报这个错              EXC_CRASH      Abnormal Exit      通常跟随的 UNIX Signal 是 SIGABRT，当前进程被系统检测到有异常行为而杀死              EXC_BAD_INSTRUCTION      Illegal Instruction      非法或未定义的指令或操作数      Unix SignalUnix Signal 是 Unix 系统的一种异步通知机制。Mach 异常在 host 层被 ux_exception 转换为相应的 Unix Signal，并通过 threadsignal 将信号投递到出错的线程。如 SIGABRT，SIGSEGV。在 Unix 层则可以注册 Signal 处理回调。如下代码是把接受到的 SIGBUS 统一用 signalHander 来处理。void signalHander(int sig){    printf(\"signal %d received.\\n\", sig);    exit();}int main () {    signal(SIGBUS, sigHanler);    char *str = \"bitnpc\";    str[0] = 'H';}常见的Unix信号下表列出了常见的 Unix Signal。在 macOS 系统中，可以输入 man signal 查看所有的 Signal 列表。在这里也可以看到。            Unix Signal      说明                  SIGSEGV      访问了无效的内存地址，这个地址存在，但是当前进程没有权限访问它。属于硬件层错误              SIGABRT      程序Crash，这个符号是由C函数abort()触发的。通常代表系统发现当前程序执行出错。属于软件层错误              SIGBUS      访问了无效的内存地址，与SIGSEGV的区别是：SIGBUS表示内存地址不存在。属于硬件层错误              SIGTRAP      Debugger相关              SIGILL      尝试执行一个非法的、未知的、没有权限的指令      NSException发生在 iOS 系统库。如 CoreFoundation，Runtime 等等。可以通过 NSSetUncaughtExceptionHandler 来注册 NSException 的捕获函数。如下代码，会在 exceptionHandler 函数中获取 exception 的一些信息。void exceptionHandler(NSException *exception){    NSString *name = [exception name];                          // 异常名称    NSString *reason = [exception reason];                      // 出现异常的原因    NSArray *stackArray = [exception callStackSymbols];         // 异常的堆栈信息    NSLog(@\"%@_%@\", name, reason);    NSLog(@\"%@\", stackArray);}int main() {    NSSetUncaughtExceptionHandler(&amp;exceptionHandler);    NSArray *array = @[@\"b\", @\"i\", @\"t\", @\"n\", @\"p\", @\"c\"];    id obj = array[6];}CrashLog符号化Crash 捕获后获得的数据都是对应的虚拟内存地址。我们需要把虚拟内存地址转化为可读的堆栈信息。 符号化的本质是在一个映射文件中，找到内存地址对应的函数的方法名。  主要有以下三种符号化方法。  使用 Xcode 来符号化  Symbolicatecrash  macOS 下的 atos 工具和 Linux 平台的替代品 atosl项目代码的符号文件在 dSYM 中。系统库的符号文件，可以从 iOS 固件中获取，也可以从 Github 上开源项目中找到对应系统的符号文件。Crash排查思路通常情况下，debug 时发生的 Crash 很好解决。但是，App 上线后，往往会出现一些本地没有遇到过，并且难以复现的 Crash。并且从 CrashLog 中往往不能直接定位问题所在。定位      搜集线索   CrashLog。系统版本，App 版本（分析改动日志），线程堆栈。  用户操作日志。有些 App 中集成进了记录用户操作行为的功能，如美团的 Logan。可以通过操作日志复现用户操作路径。  使用搜索引擎。查询是否有人遇到过类似的问题，Stackoverflow 可能会帮到你。        尝试复现   通过上面搜集到的线索，可以大概确定 Crash 发生的范围，从而帮助我们复现问题。有些野指针问题，在本地难以复现。可尝试后使用一些工具，提高野指针的崩溃率。比如 Xcode 的 Diagnostics 中提供的 Malloc Scribble，Zombie Object 等工具。  Malloc Scribble原理是通过在已释放对象中填充 0x55，使得野指针调用必然崩溃。仅本地 debug 时有效，如果想在内测包中实现此功能，需要 hook 系统库中的 free 函数。以如下代码为例（为便于说明，已关闭 ARC ）:UIView *view = [UIView new];[view release];[view setNeedsLayout];很显然，此时 view 指向的对象已释放，但是 view 指针未置为 nil。所以我们在向一个已释放的对象发送了消息。但是，编译运行后，发现并不会 Crash。打开 Malloc Scribble 后，可以从调试面板很清晰的看到，在第三行发生了 Crash。Zombie Object把已释放的对象标记为僵尸对象，Xcode 的实现方式是使用 runtime 方法 object_setClass，覆写被释放的 view 的 isa 为 _NSZombie_UIView。除了上述 Memory Management 的工具，Xcode 还提供了 Runtime Sanitization 的工具（实际上是 LLVM 编译器提供的功能）。如可以监测竞态访问的 Thread Sanitizer，可以帮助开发者发现潜在的问题。案例分析下面是一个 CrashLog，为了便于阅读，省略了不相关的部分。Incident Identifier: 61590478-FA94-496E-9208-D2016678D6D0CrashReporter Key:   TODOHardware Model:      iPhone7,2Process:         imeituan [10672]Path:            /var/containers/Bundle/Application/2140260F-0484-4CED-AC09-DEC9B620A63A/imeituan.app/imeituanIdentifier:      com.meituan.imeituanVersion:         9.1.0 (3123)Code Type:       ARM-64Parent Process:  ??? [1]Date/Time:       2018-11-12 08:44:34 +0000OS Version:      iPhone OS 10.1.1 (14B100)Report Version:  104Exception Type:  SIGSEGVException Codes: SEGV_ACCERR at 0x20Crashed Thread:  22Thread 22 Crashed:0   libobjc.A.dylib                     objc_registerClassPair + 321   Foundation                          _NSKVONotifyingCreateInfoWithOriginalClass + 1362   Foundation                          _NSKeyValueContainerClassGetNotifyingInfo + 803   Foundation                          -[NSKeyValueUnnestedProperty _isaForAutonotifying] + 844   Foundation                          -[NSKeyValueUnnestedProperty isaForAutonotifying] + 1005   Foundation                          -[NSObject(NSKeyValueObserverRegistration) _addObserver:forProperty:options:context:] + 4366   Foundation                          -[NSObject(NSKeyValueObserverRegistration) addObserver:forKeyPath:options:context:] + 1247   imeituan                            -[NSObject(RACSelectorSignal) racSignal_addObserver:forKeyPath:options:context:] (NSObject+RACSelectorSignal.m:63)8   imeituan                            -[RACKVOTrampoline initWithTarget:observer:keyPath:options:block:] (RACKVOTrampoline.m:50)9   imeituan                            -[NSObject(RACKVOWrapper) rac_observeKeyPath:options:observer:block:] (NSObject+RACKVOWrapper.m:115)10  imeituan                            __84-[NSObject(RACPropertySubscribing) rac_valuesAndChangesForKeyPath:options:observer:]_block_invoke.41 (NSObject+RACPropertySubscribing.m:0)......49  imeituan                            -[TPKxxxItem initWithText:jumpUrlString:] (TPKPOIDetailLookMoreCell.m:60)50  imeituan                            -[TPKxxxViewModel itemsWithModel:] (TPKxxxViewModel.m:102)51  imeituan                            __51-[TPKxxxViewModel setupViewModel]_block_invoke (TPKxxxViewModel.m:43)......首先，来搜索一下堆栈信息。这里可供搜索的堆栈在 0-6 行。比如我们搜索 objc_registerClassPair，它是 runtime 创建类时调用的一个方法。但是这个信息不足以定位问题。由堆栈第四行，搜索到了一片 KVO 创建同名类导致 Crash 的文章。但是，本项目是组件化的，每个 pod 都有不同的前缀，不存在不同二进制包中有多个符号并存的问题。接下来，就看看能否复现。找到 TPKxxxViewModel 所对应的页面，发现没有发生 Crash。考虑到 Crash 的线程是后台线程，猜测很有可能是多线程创建 TPKxxxItem 导致的问题。那就可以写一些测试代码来尝试复现。注意，注意该段代码执行的时机要和实际创建该 item 一致。for (int i = 0; i &lt; 5; i++) {    dispatch_async(dispatch_get_global_queue(DISPATCH_PRIORITY_DEFAULT, 0), ^{        TPKxxxItem *item = [[TPKxxxItem alloc] initWithText:@\"bit\" jumpUrlString:@\"npc\"];    });}很幸运，成功复现。Crash 位置是项目中的一个基础库。查看该基础库的改动日志，发现多了一些 swizzle 的操作。该类有一个步骤类似于 KVO 的机制，过程中会创建一个新类。但是，后续又有 KVO 该类的操作。所以，我们的问题就转化 KVO 在创建同名类的子类就会 Crash 的问题，正好契合前面搜集的资料。那么，为什么 KVO 在创建同名类的子类时会 Crash 呢？我们知道，KVO 主要做了以下几件事:  使用 objc_registerClassPair 方法，动态创建一个新类：NSKVONotifying_xxx  把新类设置为原先的类的子类，并将原先的类的 isa 指针指向新类。  把新类添加进入全局的类表里  重写新类的 set 方法在步骤一，如果创建两个同名的新类，会如何？可以写个测试代码验证一下。- (void)applicationDidFinishLaunching:(NSNotification *)aNotification {    Class testClass1 = objc_allocateClassPair([NSObject class], \"bitnpc_crash_test\", 0);    objc_registerClassPair(testClass1);    Class testClass2 = objc_allocateClassPair([NSObject class], \"bitnpc_crash_test\", 0);    objc_registerClassPair(testClass2);         # EXC_BAD_ACCESS}objc_allocateClassPair 时，返回的 class 为 nil。接着，用 objc_registerClassPair 注册新类时，由于传入的参数为 nil，导致了 crash。再查看 objc-runtime 源码（objc4-723版本），可以看出，如果 getClass(name) 返回的类不为空，则直接返回 nil，不分配新的内存空间。/************************************************************************ objc_allocateClassPair* fixme* Locking: acquires runtimeLock**********************************************************************/Class objc_allocateClassPair(Class superclass, const char *name,                              size_t extraBytes){    Class cls, meta;    rwlock_writer_t lock(runtimeLock);    // Fail if the class name is in use.    // Fail if the superclass isn't kosher.    if (getClass(name)  ||  !verifySuperclass(superclass, true/*rootOK*/)) {        return nil;    }    // Allocate new classes.    cls  = alloc_class_for_subclass(superclass, extraBytes);    meta = alloc_class_for_subclass(superclass, extraBytes);    // fixme mangle the name if it looks swift-y?    objc_initializeClassPair_internal(superclass, name, cls, meta);    return cls;}到这里，原因已经很清晰了。可以用以下流程图来表示。项目中某基础库创建了两个 TPKxxxItem_XXX，我们暂且称之为中间类。 KVO 用这两个中间类创建子类时，因为没有分配到内存空间，导致 objc_registerClassPair 时，发生了 crash。  解决方案则是在创建中间类时，对 self.class 加锁，保证只生成一个中间类。注: 生成 TPKxxxItem_XXX 没有 Crash 的原因是，多线程创建同名类时，objc_allocateClassPair 不一定返回 null，这和底层容器的实现有关。该框架内部做了判断，当 objc_allocateClassPair 返回 null 时，不执行 register 操作。但是 KVO 显然没有做这样的判断。总结本文结合了操作系统的异常控制，讨论了 Crash 的本质，成因，传递流程，说明了 Crash 的堆栈捕获层次与符号化方式，简要说明了 Crash 的排查思路，并给出了一个案例分析。除了上述流程，在 Crash 的预防、Crash 的监控止损甚至是 Crash 的自我修复等流程上也可以做出一些措施，来降低 App 的 Crash 率，提高 App 整体质量。"
  },
  
  {
    "title": "macOS 开发环境配置",
    "url": "/posts/macOS_dev_config/",
    "categories": "技术, macOS",
    "tags": "环境配置, macOS",
    "date": "2014-07-01 00:00:00 +0800",
    





    
    "snippet": "XcodeiOS/macOS App 开发必备，最新版本可从 App Store 下载，历史版本在 开发者中心 下载  如果不是开发 iOS/macOS App 就没有必要安装 Xcode，但需要安装 Xcode 命令行工具，因为很多环境和软件都会使用到和依赖它使用// 打出当前系统使用的默认 Xcodexcode-select --print-path// Xcode 多版本切换sudo ...",
    "content": "XcodeiOS/macOS App 开发必备，最新版本可从 App Store 下载，历史版本在 开发者中心 下载  如果不是开发 iOS/macOS App 就没有必要安装 Xcode，但需要安装 Xcode 命令行工具，因为很多环境和软件都会使用到和依赖它使用// 打出当前系统使用的默认 Xcodexcode-select --print-path// Xcode 多版本切换sudo xcode-select -switch /Applications/Xcode8.3/Xcode.app/Contents/Developer// 仅安装 Xcode 命令行工具xcode-select --installHomebrewHomebrew 是一款 macOS 平台下的软件包管理工具，拥有安装、卸载、更新、查看、搜索等很多实用的功能。简单的一条指令，就可以实现包管理，而不用你关心各种依赖和文件路径的情况，十分方便快捷。安装与卸载// 安装/bin/bash -c \"$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/HEAD/install.sh)\"// 卸载/bin/bash -c \"$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/HEAD/uninstall.sh)\"  /bin/bash: 使用 bash 环境运行  curl -fsSL: 使用 curl 命令下载基本使用brew install &lt;packageName&gt;      #安装任意包brew uninstall &lt;packageName&gt;    #卸载任意包brew list                       #查看已安装包列表brew update                     #更新homebrewbrew upgrade &lt;packageName&gt;      #更新指定包brew upgrade                    #更新所有包系统权限问题在 Mac OS X 10.11 系统之后，/usr/local/ 等系统目录下的文件读写是需要系统 root 权限的，以往的 Homebrew 安装如果没有指定安装路径，会默认安装在这些需要系统 root 用户读写权限的目录下，导致有些指令需要添加 sudo 前缀来执行，比如升级 Homebrew 需要：sudo brew update如果你不想每次都使用 sudo 指令，你有两种方法可以选择:  对 /usr/local 目录下的文件读写进行 root 用户授权    sudo chown -R $USER /usr/local        （推荐）安装 Homebrew 时对安装路径进行指定，直接安装在不需要系统 root 用户授权就可以自由读写的目录下&lt;install path&gt; -e \"$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)\"如果遇到无法安装的问题，可以考虑替换仓库源。参考：  Homebrew 中文主页  Homebrew Bottles 源使用帮助  Homebrew Cask 源使用帮助  Homebrew Core 源使用帮助终端工具macOS 自带的终端，用起来虽然有些不太方便，界面也不够友好。iTerm2 是一款相对比较好用的终端工具。iTerm2 常用操作包括主题选择、声明高亮、自动填充建议、隐藏用户名和主机名、分屏效果等.brew cask install iterm2配置 Oh My ZshOh My Zsh 是对主题的进一步扩展sh -c \"$(curl -fsSL https://raw.github.com/ohmyzsh/ohmyzsh/master/tools/install.sh)\"设置 zsh 为当前用户的默认 shellchsh -s /bin/zsh修改中意的主题，将主题修改为ZSH_THEME=”ys”vim ~/.zshrcRVMRVM 是一个便捷的多版本 ruby 环境的管理和切换工具。安装安装目录位于 ~/.rvmcurl -sSL https://get.rvm.io | bash -s stablesource ~/.bashrcsource ~/.bash_profile修改RVM源为了提高安装速度，修改 RVM，改用 ruby-china 镜像源。echo \"ruby_url=https://cache.ruby-china.org/pub/ruby\" &gt; ~/.rvm/user/db使用查看版本rvm list known              #查看可安装的版本rvm install ruby-2.7.2      #安装ruby 2.7.2版本rvm list                    #查询已经安装的ruby版本创建 gemset，当前使用的 gems 环境可以在 ~/.rvm/gems 路径中查看rvm gemset create tonyrvm use 2.7.0@tony --default安装 gems，如 bundler, cocoapodsgem install cocoapods -v 1.8.1pod --version切换版本rvm use 3.0.0               #使用3.0.0版本rvm use 3.0.0 --default     #使用3.0.0版本，并设置该版本为默认版本卸载版本rvm remove 3.0.0            #卸载一个已安装版本更新RVMrvm get stableGit安装macOS 自带 Git，其版本取决于 macOS 版本配置配置全局用户名和邮件，也可切换到指定目录后配置// 全局配置git config --global user.name \"Your Name Here\"git config --global user.email \"your_email@youremail.com\"// 按 git 仓库配置，配置后，可在 .git 目录下的 config 文件查看git config user.name \"Your Name Here\"git config user.email \"your_email@youremail.com\"配置 SSH keycd ~/.sshls -alssh-keygen -t rsa -C \"your_email@example.com\"注：如有配置多个 ssh-key 的需求，需要在 ~/.ssh 添加 config 文件。如下图所示，GitHub 和 内网 Gitlab 使用了不同的 ssh-key。config 文件的格式如下Host github.comHostName github.comIdentityFile ~/.ssh/githubPreferredAuthentications publickeyUser tonyHost gitlab.comHostName gitlab.comIdentityFile ~/.ssh/gitlabPreferredAuthentications publickeyUser tony"
  }
  
]

